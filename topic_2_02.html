<!DOCTYPE html>
<html lang="ru">
<head>
    <title>2.02 - Работа с коллекциями в Java 7</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <style>
        body {
            background: #dfdfdf;
        }

        /* Remove the navbar's default margin-bottom and rounded borders */
        .jumbotron {
            padding-top: 0;
            padding-bottom: 0;
        }

        #header {
            background-color: #445566;
        }

        #header h2, #header h4, #header h3, #header h5, #header p {
            margin-left: -10px;
            color: #ededed;
        }

        #header h2 {
            font-weight: bold;
        }

        #header h4 {
            font-size: 1.5em;
        }

        #content {
            background: white;
            padding-right: 9%;
            box-sizing: border-box;
        }

        p {
            text-align: justify;
        }

        img {
            max-width: 100%;
        }

        ul.nav, ul.side_menu {
            list-style-type: none;
            margin-left: -20px;
        }

        .navbar {
            margin-bottom: 0;
            border-radius: 0;
        }

        .navbar-inverse {
            background-color: #445566;
            border: none;
            border-top: 1px solid white;
        }

        .navbar-inverse .navbar-nav > .active > a, .navbar-inverse .navbar-nav > .active > a:hover, .navbar-inverse .navbar-nav > li > a:hover {
            background-color: #293b4c;
        }

        /* Set height of the grid so .sidenav can be 100% (adjust as needed) */
        .row.content {
            height: 450px
        }

        /* Set gray background color and 100% height */
        .sidenav {
            padding-top: 20px;
            height: 100%;
        }

        .btn-info {
            color: #fff;
            background-color: #445566;
            border: none;
            border-radius: 0;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .btn-info:hover {
            background-color: #293b4c;
        }

        .navbar-inverse .navbar-toggle:hover {
            background-color: #293b4c;
        }

        .hide {
            visibility: hidden;
        }

        .disa {
            cursor: default;
            opacity: 0.6;

        }

        .disa:hover {
            background-color: #445566;
        }

        /* Set black background color, white text and some padding */
        footer {
            background-color: #293b4c;
            color: white;
            padding: 15px;
        }

        #up {
            color: #fff;
            position: fixed;
            display: block;
            background: #293b4c;
            width: 40px;
            height: 40px;
            bottom: 64px;
            right: 30px;
            opacity: 0;
            border-radius: 50%;
            padding-left: 12px;
            padding-top: 8px;
            box-sizing: border-box;
        }

        /* On small screens, set height to 'auto' for sidenav and grid */
        @media screen and (max-width: 990px) {
            #content {
                padding-right: 10px;
            }

            #up {
                display: none !important;
            }
        }

        /* On small screens, set height to 'auto' for sidenav and grid */
        @media screen and (max-width: 767px) {
            .sidenav {
                height: auto;
                padding: 15px;
            }

            .row.content {
                height: auto;
            }
        }

        @media only screen and (max-width: 600px) {
            img.small_img {
                width: 40%;
                height: auto;
            }

            img.big_img {
                width: 90%;
                height: auto;
            }
        }

        .justified {
            text-align: justify;
            font-weight: normal
        }

        tt {
            color: #446699;
        }
    </style>
</head>
<body id="top">
<div class="container-fluid text-left" id="header">
    <div class="container text-left col-md-3 col-sm-12">
        <img src="Images/icon-java.png" style="padding-top: 15px; box-sizing: border-box;">
    </div>
    <div class="container text-left col-md-9 col-sm-12">
        <h2>Язык программирования и технологии Java</h2>
        <h5>Разработчик курса Л. В. Иванов</h5>
        <h4>Модуль 1 Объектно-ориентированное программирование и язык Java</h4>

    </div>
</div>
<nav class="navbar navbar-inverse">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>
        <div class="collapse navbar-collapse" id="myNavbar">
            <!--div class="col-sm-12 col-md-3 sidenav">
            </div-->

            <ul class="nav navbar-nav">
                <li><a href="index.html">Главная</a></li>
                <li><a href="topic_1_01.html">Объектно-ориентированное программирование и язык Java</a>
                </li>
                <li class="active"><a href="topic_2_01.html">Платформа Java SE</a></li>
                <li><a href="">Разработка приложений JAVA EE</a></li>
            </ul>

        </div>
    </div>
</nav>

<div class="container-fluid text-left">
    <div class="row content">
        <div class="col-sm-12 col-md-3 sidenav">
            <ul class="side_menu">
                <li>1 Объектно-ориентированное программирование и язык Java
                    <ul class="side_menu">
                        <li><a href="topic_1_01.html">01 Парадигмы программирования. Основы объектно-ориентированного
                            подхода</a></li>
                        <li><a href="topic_1_02.html">02 Язык программирования Java и Java-платформа</a></li>
                        <li><a href="topic_1_03.html">03 Синтаксические конструкции языка Java</a></li>
                        <li><a href="topic_1_04.html">04 Ссылочные типы. Массивы. Строки и классы-оболочки</a></li>
                        <li><a href="topic_1_05.html">05 Определение классов.  Наследование и полиморфизм</a></li>
                        <li><a href="topic_1_06.html">06 Вложенные типы. Интерфейсы. Лямбда-выражения и ссылки на методы</a></li>
                        <li><a href="topic_1_07.html">07 Перечисления. Исключения. Использование обобщений</a></li>
                        <li><a href="topic_1_08.html">08 Понятие паттернов проектирования. Порождающие паттерны</a></li>
                    </ul>
                </li>
                <li>2 Платформа Java SE
                  <ul class="side_menu">
                        <li><a href="topic_2_01.html">01 Платформа Java SE и ее составляющие</a></li>
                        <li>02 Работа с коллекциями в Java 7</li>
                        <li><a href="topic_2_03.html">03 Работа с текстовыми данными. Локализация</a></li>
                        <li><a href="topic_2_04.html">04 Работа с потоками ввода-вывода и файловой системой</a></li>
                        <li><a href="topic_2_05.html">05 Работа с XML. XML-сериализация</a></li>
                        <li>06 Тестирование и управление сборкой. Ведение системного журнала</li>
                        <li>07 Работа с потоками выполнения</li>
                        <li>08 Работа с контейнерами Java 8. Stream API</li>
                        <li>09 Поддержка сетевого взаимодействия</li>
                        <li>10 Работа с базами данных</li>
                        <li>11 Использование RTTI и рефлексии. Метапрограммирование. Аннотации</a></li>
                        <li>12 </a>Использование структурных паттернов</li>
                  </ul>
                </li>
                <li>3 Основы разработки приложений Java EE
                    <ul class="side_menu">
                        <li>01 Платформа Java EE. Web-приложения. Создание сервлетов</li>
                        <li>02 Основы создания страниц JSP</li>
                        <li>03 Работа с EJB. Создание Web-сервисов</li>
                        <li>04 Использование Spring Framework</li>
                        <li>05 Использование паттернов поведения и распределения ответственности </li>
                        <li>06 Дополнительные возможности Java 11</li>
                    </ul>
                </li>
            </ul>
      </div>
        <div class="col-sm-12 col-md-9 text-left" id="content">
            <div class="w3-clear nextprev">
                <a class="btn btn-info float-left" href="topic_2_01.html">Предыдущая</a>
                <a class="btn btn-info float-left" href="topic_2_03.html">Следующая</a>
            </div>
            <h1>Работа с коллекциями в Java 7</h1>
<h2>1 Теоретическая часть</h2>
<h3>1.1  Обзор стандартных контейнерных интерфейсов и классов</h3>
<h4>1.1.1 Общие сведения </h4>
<p><em>Контейнерный класс</em> - это класс, объекты которого используются для хранения объектов других типов (ссылок на другие типы). Также используется термин &quot;<em>коллекция</em>&quot; - некоторое хранище элементов, поддерживающее различные способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним.</p>
<p>Библиотека классов и интерфейсов для поддержки коллекций называется Java collections framework (JCF) . Он появился начиная с версии Java 1.2. В версии 1.5 в JCF добавлена поддержка обобщений. </p>
<p>Средства Java для работы с коллекциями предоставляют унифицированную архитектуру для представления и управления наборами данных. Эта архитектура позволяет работать с коллекциями независимо от деталей их представления. Средства для работы с коллекциями включают более десятка интерфейсов, а также стандартные реализации этих интерфейсов и набор алгоритмов для работы с ними. Контейнерные классы реализованы в пакете <code>java.util</code>. Начиная с Java 5, все контейнерные классы реализованы как обобщенные.</p>
<p>Использование коллекций обеспечивает повышение эффективности программ за счет использования высокоэффективных алгоритмов, а также содействует созданию кода, пригодного для повторного использования. Основными элементами средств работы с коллекциями являются следующие:</p>
<ul>
  <li>интерфейсы</li>
  <li>стандартные реализации интерфейсов</li>
  <li>алгоритмы</li>
  <li>утилиты для работы с массивами</li>
</ul>
<p>Кроме того, поддерживаются контейнеры Java 1.1, не обеспечивающие стандартизированного интерфейса, и вследствие этого считающиеся устаревшими и не рекомендованы для использования. Это <code>Vector</code>, <code>Enumeration</code>, <code>Stack</code>, <code>BitSet</code> и некоторые другие. Например, класс <code>Vector</code> предоставляет функциональность, аналогичную <code>ArrayList</code>. Сейчас эти контейнеры считаются устаревшими и не рекомендованы к применению. Вместо них следует использовать соответствующие обобщенные контейнеры Java 5.</p>
<p>Стандартные контейнеры Java позволяют хранить ссылки на объекты классов, производных от <code>java.lang.Object</code>. Контейнерные интерфейсы и классы представлены в пакете <code>java.util</code>, а также во вложенных в него пакетах (например, <code>java.util.concurrent</code>). Начиная с Java 5, все контейнерные классы реализованы как обобщенные.</p>
<p>Существует два базовых интерфейса, в которых декларирована функциональность контейнерных классов: <code>Collection</code> и <code>Map</code>. Интерфейс <code>Collection</code> является базовым для интерфейсов <code>List</code> (список), <code>Set</code> (множество), <code>Queue</code> (очередь) и <code>Deque</code> (очередь с двумя концами). Ниже приведены наиболее часто используемые методы, объявленные в интерфейсе <code>Collection</code>.</p>
<p>Интерфейс <code>List</code> (список) описывает пронумерованную коллекцию (последовательность), элементы которой могут повторяться. Существует стандартная абстрактная реализации списка - класс <code>AbstractList</code>. Этот класс, производный от <code>AbstractCollection</code>, предоставляет ряд полезных средств. Практически в той или иной форме реализованы все методы, кроме <code>get()</code> и <code>size()</code>. Тем не менее, для конкретной реалзации списка большинство функций следует перекрыть. В качестве вложенного размещен класс, реализующий интерфейс <code>Iterator</code>. класс <code>AbstractList</code> - базовый для <code>ArrayList</code>. Класс <code>AbstractSequentialList</code>, производный от <code>AbstractList</code>, является базовым для класса <code>LinkedList</code>.</p>
<p>Интерфейс <code>Set</code> реализован классами <code>HashSet</code> и <code>LinkedHashSet</code>. Интерфейс <code>SortedSet</code>, производный от <code>Set</code>, предоставляет производный интерфейс <code>NavigableSet</code>, реализованный классом <code>TreeSet</code>. Интерфейс <code>Map</code> реализован классом <code>HashMap</code>. Интерфейс <code>SortedMap</code>, производный от <code>Map</code>, реализован классом <code>TreeMap</code>.</p>
<p>Классы <code>HashSet</code>, <code>LinkedHashSet</code> и <code>HashMap</code> используют для идентификации элементов так называемые хеш-коды. <i>Хэш-код</i> <code>-</code> это уникальная последовательность битов фиксированной длины. Для каждого объекта эта последовательность считается уникальной. Хэш-коды обеспечивают быстрый доступ к данным по некоторому ключу. Все объекты Java могут генерировать хэш-коды: метод <code>hashCode()</code> определен для класса <code>Object</code>.</p>
<p>Для большинства коллекций присутствуют как &quot;обычные&quot; реализации, так и реализации, безопасные с точки зрения потоков управления, например <code>CopyOnWriteArrayList</code>, <code>ArrayBlockingQueue</code> и т. д. Соответствующие интерфейсы и реализации будут рассмотрены позже.</p>
<h4>1.1.2 Интерфейс Collection</h4>
<p>Интерфейс <code>Collection</code> является базовым для многих интерфейсов Collection Framework и объявляет наиболее общие методы коллекций:</p>
<div>
  <table class="simple" width="70%" border="1" cellspacing="0" cellpadding="5">
    <tr>
      <th width="45%">Метод</th>
      <th width="80%">Описание</th>
    </tr>
    <tr>
      <td width="45%"><p><code><strong>int</strong> size()</code></p></td>
      <td width="80%">Возвращает размер коллекции</td>
    </tr>
    <tr>
      <td width="45%"><code> <strong>boolean</strong> isEmpty()</code></td>
      <td width="80%">Возвращает <strong><code>true</code></strong>, если коллекция пуста</td>
    </tr>
    <tr>
      <td width="45%"><code><b>boolean</b> contains(Object o)</code></td>
      <td>Возвращает <strong><code>true</code></strong>, если коллекция содержит объект</td>
    </tr>
    <tr>
      <td width="45%"><code>Iterator&lt;E&gt; iterator</code></td>
      <td>Возвращает итератор - объект, последовательно указывающий на элементы </td>
    </tr>
    <tr>
      <td width="45%"><code>Object[] toArray()</code></td>
      <td>Возвращает массив ссылок на <code>Object</code>, содержащий копии всех элементов коллекции</td>
    </tr>
    <tr>
      <td width="45%"><code>&lt;T&gt; T[] toArray(T[] a)</code></td>
      <td>Возвращает массив ссылок на <code>T</code>, содержащий копии всех элементов коллекции</td>
    </tr>
    <tr>
      <td width="45%"><code><b>boolean</b> add(E e)</code></td>
      <td>Добавляет объект в коллекцию. Возвращает <code><strong>true</strong></code>, если объект добавлен</td>
    </tr>
    <tr>
      <td width="45%"><code><b>boolean</b> remove(Object o)</code></td>
      <td>Удаляет объект из коллекции</td>
    </tr>
    <tr>
      <td width="45%"><code><b>boolean</b> containsAll(Collection&lt;?&gt; c)</code></td>
      <td>Возвращает <strong><code>true</code></strong> если коллекция содержит другую коллекцию</td>
    </tr>
    <tr>
      <td width="45%"><code><b>boolean</b> addAll(Collection&lt;? <strong>extends</strong> E&gt; c)</code></td>
      <td>Добавляет объекты в коллекцию; возвращает <strong><code>true</code></strong>, если объекты добавлены</td>
    </tr>
    <tr>
      <td width="45%"><code><b>boolean</b> removeAll(Collection&lt;?&gt; c)</code></td>
      <td>Удаляет объекты из коллекции</td>
    </tr>
    <tr>
      <td width="45%"><code><b>boolean</b> retainAll(Collection&lt;?&gt; c)</code></td>
      <td>Оставляет объекты, имеющиеся во второй коллекции</td>
    </tr>
    <tr>
      <td width="45%" height="33"><code><strong>void</strong> clear()</code></td>
      <td>Удаляет все элементы из коллекции</td>
    </tr>
  </table>
</div>
<p><em>Примечание</em>: в таблице не указаны методы с реализацией по умолчанию, добавленные в Java 8.</p>
<p>Следующий пример демонстрирует работу методов интерфейса. В примере используется класс <code>ArrayList</code> как самая простая реализация интерфейса <code>Collection</code>:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.*;

<b>public class</b> CollectionDemo {

    <b>public static void</b> main(String[] args) {
        Collection&lt;Integer&gt; c = <b>new</b> ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));
        System.out.println(c.size());      // 5
        System.out.println(c.isEmpty());   // false
        System.out.println(c.contains(4)); // true
        c.add(6);
        System.out.println(c);             // [1, 2, 3, 4, 5, 6]
        c.remove(1);
        System.out.println(c);             // [2, 3, 4, 5, 6]
        Collection&lt;Integer&gt; c1 = <b>new</b> ArrayList&lt;&gt;(Arrays.asList(3, 4));
        System.out.println(c.containsAll(c1));// true
        c.addAll(c1);
        System.out.println(c);             // [2, 3, 4, 5, 6, 3, 4]
        Collection&lt;Integer&gt; c2 = <b>new</b> ArrayList&lt;&gt;(c); // копия 
        c.removeAll(c1);
        System.out.println(c);             // [2, 5, 6]
        c2.retainAll(c1);
        System.out.println(c2);            // [3, 4, 3, 4]
        c.clear();
        System.out.println(c);             // []       
    }

}</pre>
</blockquote>
<h3>1.2 Использование списков</h3>
<p>Как и в массивах, доступ к элементам может осуществляться по индексу (но не через операцию <code>[]</code>). В отличие от массивов, размер списков может динамически изменяться. Java предоставляет варианты создания списков, как с применением обобщений, так и без них. Вариант без обобщений считается устаревшим и нежелательным.</p>
<p>Существует стандартная абстрактная реализации списка - класс <code>AbstractList</code>. Этот класс, производный от <code>AbstractCollection</code>, предоставляет ряд полезных средств. Практически в той или иной форме реализованы все методы, кроме <code>get()</code> и <code>size()</code>. Тем не менее, для конкретной реалзации списка большинство функций следует перекрыть. В качестве вложенного размещен класс, реализующий интерфейс <code>Iterator</code>. класс <code>AbstractList</code> - базовый для <code>ArrayList</code>. Класс <code>AbstractSequentialList</code>, производный от <code>AbstractList</code>, является базовым для класса <code>LinkedList</code>.</p>
<p>Создать пустой список ссылок на объекты некоторого типа (<code>SomeType</code>) можно с помощью конструктора по умолчанию:</p>
<blockquote>
  <pre>List&lt;SomeType&gt; al = <b>new</b> ArrayList&lt;SomeType&gt;();</pre>
</blockquote>
<p>Можно сразу описать ссылку на <code>ArrayList</code>:</p>
<blockquote>
  <pre>ArrayList&lt;SomeType&gt; al = <b>new</b> ArrayList&lt;SomeType&gt;();</pre>
</blockquote>
<p>Второй вариант в некоторых случаях использовать не желательно, поскольку в таком случае снижается гибкость программы. Первый вариант позволит легко реализацию списка <code>ArrayList</code> заменить на любую другую реализацию интерфейса <code>List</code>, которая больше соответствует требованиям конкретной задачи. Во втором случае есть соблазн вызывать методы, специфические для <code>ArrayList</code>, поэтому переход на другую реализацию будет затруднен.</p>
<p>Реализация Класс <code>ArrayList</code> содержит в качестве поля массив <code>elementData</code> элементов типа <code>Object</code>. Физический размер массива (capacity), если не вызывать конструктор с явным указанием этого размера, по умолчанию равен 10. При каждом добавлении элемента вызывается внутренний метод <code>ensureCapacity()</code>, который в случае заполнения массива осуществляет создание нового массива с переписыванием в него имеющихся элементов. Размер нового массива вычисляется по формуле <code>(старый_размер * 3) / 2 + 1</code>.</p>
<p>При удалении элементов физический размер массива не уменьшается. Для экономии памяти после многократного удаления элементов целесообразно вызывать метод <code>trimToSize()</code>.</p>
<p>Создав пустой список, в него можно добавлять элементы с помощью функции <code>add()</code>. Метод <code>add()</code> с одним аргументом типа <code>Object</code> (или производных типов) добавляет элемент в конец списка. Если функция вызывается с двумя аргументами, новый элемент вставляется в список в позиции, указанной первым параметром:</p>
<blockquote>
  <pre>List&lt;String&gt; al = <b>new</b> ArrayList&lt;String&gt;();
al.add(&quot;abc&quot;);
al.add(&quot;def&quot;);
al.add(&quot;xyz&quot;);
al.add(2, &quot;ghi&quot;); // Вставка новой строки перед &quot;xyz&quot;</pre>
</blockquote>
<p>Можно создать новый список с использованием существующего. Новый список содержит ссылку на копии элементов. Например:</p>
<blockquote>
  <pre>List&lt;String&gt; a1 = <b>new</b> ArrayList&lt;String&gt;(al);    </pre>
</blockquote>
<p>С помощью статической функции <code>asList()</code> класса <code>java.util.Arrays</code> можно создать список из существующего массива. Массив можно создать непосредственно в списке параметров функции. Например:</p>
<blockquote>
  <pre>String[] arr = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};
List&lt;String&gt; a2 = Arrays.asList(arr);
List&lt;String&gt; a3 = Arrays.asList(&quot;four&quot;, &quot;five&quot;);    </pre>
</blockquote>
<p>Для списков перегружена функция <code>toString()</code>, которая позволяет вывести все элементы списка на экран без использования циклов. Элементы выводятся в квадратных скобках:</p>
<blockquote>
  <pre>System.out.println(a3); // [four, five]    </pre>
</blockquote>
<p>Списки допускают работу с отдельными элементами. Метод <code>size()</code> возвращает количество элементов, содержащихся в списке. Метод <code>get()</code> возвращает элемент с указанным индексом (позиция в списке). Как и элементы массивов, элементы списков пронумерованы с нуля. В следующем примере строки выводятся с помощью функции <code>println()</code>:</p>
<blockquote>
  <pre>List&lt;String&gt; al = <b>new</b> ArrayList&lt;String&gt;();
al.add(&quot;abc&quot;);
al.add(&quot;def&quot;);
al.add(&quot;xyz&quot;);
<b>for</b> (<b>int</b> i = 0; i &lt; al.size(); i++) {
    System.out.println(al.get(i));
}</pre>
</blockquote>
<p>Функция <code>subList(fromIndex, toIndex)</code> возвращает список, составленный из элементов начиная с элемента с индексом <code>fromIndex</code> и не включая элемент с индексом <code>toIndex</code>. Например:</p>
<pre>System.out.println(al.subList(1, 3)); // [def, xyz]    </pre>
<p>Метод <code>set()</code> позволяет изменить объект, хранящийся в указанной позиции. Метод <code>remove()</code> удаляет объект в указанной позиции:</p>
<blockquote>
  <pre>al.set(0, &quot;new&quot;);
al.remove(2);
System.out.println(al); // [new, def]</pre>
</blockquote>
<p> Функция <code>contains()</code> возвращает <b><code>true</code></b>, если список содержит указанный элемент. Например:</p>
<blockquote>
  <pre><b>if</b> (al.contains(&quot;abc&quot;)) {
    System.out.println(al);
}    </pre>
</blockquote>
<p>Функция <code>toArray()</code> возвращает ссылку на массив копий объектов, ссылки на которые хранятся в списке.</p>
<blockquote>
  <pre>Object [] a = al.toArray();
System.out.println(a[1]);    // def
(al.toArray()) [2] = &quot;text&quot;; // Изменение элементов нового массива</pre>
</blockquote>
<p>Для сохранения целых и действительных значений в коллекциях часто используют классы-оболочки <code>Integer</code> и <code>Double</code> соответственно.</p>
<p>Можно удалять элементы с помощью метода <code>remove(индекс_удаляемого_элемента)</code>. При удалении элементов текущая величина <code>capacity</code> не уменьшается, что может привести к своеобразным утечкам памяти. Поэтому для экономии памяти есть смысл вызывать метод <code>trimToSize() </code>.</p>
<p>В тех случаях, когда операции добавления и удаления элементов в произвольных местах применяют чаще, чем выбор произвольного элемента, целесообразно использовать класс <code>LinkedList</code>, который сохраняет объекты с помощью связанного списка. Для удобной работы добавлены также методы <code>addFirst()</code>, <code>addLast()</code>, <code>removeFirst()</code> и <code>removeLast()</code>.</p>
<blockquote>
  <pre>LinkedList&lt;String&gt; list = <b>new</b> LinkedList&lt;String&gt;();
list.addLast(&quot;last&quot;); // То же, что list.add(&quot;last&quot;);
list.addFirst(&quot;first&quot;);
System.out.println(list); // [first, last]
list.removeFirst();
list.removeLast();
System.out.println(list); // []</pre>
</blockquote>
<p>Эти специфические функции добавлены именно в <code>LinkedList</code>, поскольку они не могут быть эффективно реализованы в <code>ArrayList</code> с применением массивов.</p>
<p>Связный список &#8211; это одна из так называемых динамических структур данных. Другие примеры таких структур &#8211; очереди, стеки и бинарные деревья. <i>Связный список</i> представляет собой линейную структуру данных, построенную из отдельных элементов, содержащих непосредственно данные и ссылки (указатели) на соседние элементы. Обычно для представления отдельного элемента (узла) используется отдельный класс (структура, запись, в зависимости от языка).</p>
<p>Связные списки могут быть односвязными и двусвязными. В <i>односвязном списке</i> элементы содержат ссылки только на следующий элемент (или на <b><code>null</code></b>, если элемент &#8211; последний). Каждый элемент <i>двусвязного списка</i>, кроме непосредственно данных, содержит ссылки на предыдущий и последующий элементы. Для крайних элементов соответствующие ссылки также равны <b><code>null</code></b>.</p>
<p>Существуют также циклические связные списки, в которых последний элемент указывает на первый и наоборот.</p>
<p>Связный список, реализованный в Java контейнером <code>LinkedList</code>, представляет собой двунаправленный список, где каждый элемент содержит ссылки на предыдущий и следующий элементы. Отдельный элемент списка представлен следующим внутренним классом:</p>
<blockquote>
  <pre><b>private</b> <b>static</b> <b>class</b> Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
        <b>this</b>.item = element;
        <b>this</b>.next = next;
        <b>this</b>.prev = prev;
    }

}</pre>
</blockquote>
<p>Для прохождения по списку объектов используется итератор - специальный вспомогательный объект. Интерфейс <code>Iterator</code>, определенный в пакете <code>java.util</code>. Любой итератор имеет три метода:</p>
<blockquote>
  <pre><b>boolean</b> hasNext(); // проверяет, есть ли еще элементы в контейнере,
                   // и возвращает true, если еще есть элементы последовательности
Object  next();    // возвращает ссылку на следующий элемент
<b>void</b>    remove();  // удаляет последний выбранный элемент (на который ссылается итератор)</pre>
</blockquote>
<p></p>
<p>Первое обращение к методу <code>next()</code> возвращает ссылку на начальный элемент последовательности. Коллекции Java возвращают объект-итератор с помощью метода <code>iterator()</code>:</p>
<blockquote>
  <pre>List&lt;String&gt; s = <b>new</b> ArrayList&lt;String&gt;();
s.add(&quot;First&quot;);
s.add(&quot;Second&quot;);
<strong>for</strong> (Iterator&lt;String&gt; i = s.iterator(); i.hasNext(); ) {
    System.out.println(i.next());
}</pre>
</blockquote>
<p>Как видно из приведенного примера, итератор тоже является обобщенным типом. Новая форма цикла <b><code>for</code></b> позволяет обойти список без явного создания итератора:</p>
<blockquote>
  <pre>
List&lt;Integer&gt; a = <b>new</b> ArrayList&lt;Integer&gt;();
a.add(1);
a.add(2);
a.add(3);
a.add(4);
<b>for</b> (Integer i : a) {
    System.out.print(i + &quot; &quot;);
}</pre>
</blockquote>
<p>Специальный вид итератора списка, <code>ListIterator</code>, предоставляет дополнительные возможности итерации, в частности, проход по списку в обратном порядке. В следующем примере для проверки, является ли слово палиндромом используется список символов и <code>ListIterator</code>, обеспечивающий проход в обратном порядке:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.*;

<b>public</b> <b>class</b> ListIteratorTest {

    <b>public</b> <b>static</b> <b>void</b> main(String[] args) {
        String palStr = &quot;racecar&quot;;
        List&lt;Character&gt; palindrome = <b>new</b> LinkedList&lt;Character&gt;();
        <b>for</b> (<b>char</b> ch : palStr.toCharArray()) {
            palindrome.add(ch);
        }
        System.out.println(&quot;Input string is: &quot; + palStr);
        ListIterator&lt;Character&gt; iterator = palindrome.listIterator();
        ListIterator&lt;Character&gt; revIterator = palindrome.listIterator(palindrome.size());
        <b>boolean</b> result = <b>true</b>;
        <b>while</b> (revIterator.hasPrevious() &amp;&amp; iterator.hasNext()) {
            <b>if</b> (iterator.next() != revIterator.previous()) {
                result = <b>false</b>;
                <b>break</b>;
            }
        }
        <b>if</b> (result) {
            System.out.print(&quot;Input string is a palindrome&quot;);
        }
        <b>else</b> {
            System.out.print(&quot;Input string is not a palindrome&quot;);
        }
    }

}</pre>
</blockquote>
<h3>1.3 Работа с множествами</h3>
<p><i>Множество</i> - это коллекция, не содержащая одинаковых элементов. Три основных реализации интерфейса <code>Set</code> - <code>HashSet</code>, <code>LinkedHashSet</code> и <code>TreeSet</code>. Как и списки, множества являются обобщенными типами. Классы <code>HashSet</code> и <code>LinkedHashSet</code> используют хеш-коды для идентификации элементов. Класс <code>TreeSet</code> использует двоичное дерево для сохранения элементов и гарантирует их определенный порядок. </p>
<p>Внутренняя организация множеств основана на использовании ассоциативных массивов и будет рассмотрена ниже.</p>
<p>Метод <code>add()</code> добавляет элемент к множеству и возвращает <b><code>true</code></b> если элемент ранее отсутствовал. В противном случае элемент не добавляется, а метод <code>add()</code> возвращает <code><b>false</b></code>. Все элементы множества удаляются с помощью метода <code>clear()</code>.</p>
<blockquote>
  <pre>Set&lt;String&gt; s = <b>new</b> HashSet&lt;String&gt;();
System.out.println(s.add(&quot;First&quot;));  // true
System.out.println(s.add(&quot;Second&quot;)); // true
System.out.println(s.add(&quot;First&quot;));  // false
System.out.println(s);               // [First, Second]
s.clear();
System.out.println(s);               // []
</pre>
</blockquote>
<p>Метод <code>remove()</code> удаляет указанный элемент множества, если таковой имеется. Метод <code>contains()</code> возвращает <b><code>true</code></b>, если множество содержит указанный элемент.</p>
<p>В приведенном ниже примере к множеству целых чисел добавляется десять случайных значений в диапазоне от -9 до 9:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.*;

<b>public class</b> SetOfIntegers {

    <b>public static void</b> main(String[] args) {
        Set&lt;Integer&gt; set = <b>new</b> TreeSet&lt;Integer&gt;();
        Random random = <b>new</b> Random();
        <b>for</b> (<b>int</b> i = 0; i &lt; 10; i++) {
            Integer k = random.nextInt() % 10;
            set.add(k);
        }
        System.out.println(set);
    }

}</pre>
</blockquote>
<p>Результирующее множество, как правило, содержит менее 10 цифр, поскольку отдельные значения могут повторяться. Поскольку мы используем <code>TreeSet</code>, числа хранятся и выводятся в упорядоченном виде (по умолчанию - по возрастанию). Для того, чтобы добавить именно десять различных чисел, программу можно модифицировать, например, с применением цикла <code><b>while</b></code> вместо <b><code>for</code></b>:</p>
<blockquote>
  <pre><b>while</b> (set.size() &lt; 10) {
    . . .
}</pre>
</blockquote>
<p>Можно создать массив, содержащий копии елементов множества. Например, так можно вывести элементы в обратном порядке:</p>
<blockquote>
  <pre><b>for</b> (<b>int</b> i = set.size() - 1; i &gt;= 0; i--) {
    System.out.println(set.toArray()[i]);
}
</pre>
</blockquote>
<p>Поскольку множество может содержать только различные элементы, его можно использовать для подсчета различных слов, букв, цифр и т. п. - создается множество и вызывается метод <code>size()</code>. Применяя <code>TreeSet</code>, можно выводить слова и буквы в определенном порядке (по умолчанию - в алфавитном).</p>
<p>Порядок указания порядка элементов <code>TreeSet</code> можно задать, реализовав интерфейс <code>Comparable</code>, либо передав в конструктор <code>TreeMap</code> ссылку на объект класса, реализующий интерфейс <code>Comparator</code> . Например, так можно отсортировать дерево в обратном порядке:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.*;

<b>public class</b> CompTest {

    <b>public static void</b> main(String args[]) {
        TreeSet&lt;String&gt; ts = <b>new</b> TreeSet&lt;String&gt;(<b>new</b> Comparator&lt;String&gt;() 
        { 
            @Override
            <b>public int</b> compare(String s1, String s2) {
                <b>return</b> s2.compareTo(s1);
            }
        });
        ts.add(&quot;C&quot;);
        ts.add(&quot;E&quot;);
        ts.add(&quot;D&quot;);
        ts.add(&quot;B&quot;);
        ts.add(&quot;A&quot;);
        ts.add(&quot;F&quot;);
        <b>for</b> (String element : ts)
            System.out.print(element + &quot; &quot;);
        }
    }
}</pre>
</blockquote>
<h3>1.4 Работа с очередями и стеками</h3>
<p><i>Очередь</i> в широком смысле представляет собой структуру данных, заполняемую поэлементно, и позволяющую извлекать объекты по определенному правилу. В узком смысле этим правилом является &quot;первый пришёл - первый вышел&quot; (FIFO, First In — First Out). В очереди, организованной по принципу FIFO, добавление элемента возможно лишь в конец очереди, извлечение - только из начала очереди.</p>
<p>В библиотеке контейнеров очередь представлена интерфейсом <code>Queue</code>. Методы, объявленные в этом интерфейсе, представлены в следующей таблице:</p>
<div>
  <table class="simple" width="60%" border="1" cellspacing="0" cellpadding="5">
    <tr>
      <th width="30%">Тип операции</th>
      <th width="35%">Генерирует исключение</th>
      <th width="35%">Возвращает специальное значение</th>
    </tr>
    <tr>
      <td width="30%">Добавление</td>
      <td width="35%"><code>add(e)</code></td>
      <td width="35%"><code>offer(e)</code></td>
    </tr>
    <tr>
      <td width="30%">Удаление с получением элемента</td>
      <td width="35%"><code>remove()</code></td>
      <td width="35%"><code>poll()</code></td>
    </tr>
    <tr>
      <td width="30%">Получение элемента без удаления</td>
      <td width="35%"><code>element()</code></td>
      <td width="35%"><code>peek()</code></td>
    </tr>
  </table>
</div>
<p>Метод <code>offer()</code> возвращает <b><code>false</code></b>, если не удалось добавить элемент, например, если реализована очередь с ограниченным количеством элементов. В этом случае метод <code>add()</code> генерирует исключение. Аналогично <code>remove()</code> и <code>element()</code> генерируют исключение, если очередь пустая, а <code>poll()</code> и <code>peek()</code> в этом случае возвращают <b><code>null</code></b>.</p>
<p>Для реализации очереди удобнее всего использовать класс <code>LinkedList</code>, реализующий интерфейс <code>Queue</code>. Например:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.LinkedList;
<b>import</b> java.util.Queue;

<b>public class</b> SimpleQueueTest {
 
    <b>public static void</b> main(String[] args) {
        Queue&lt;String&gt; queue = <b>new</b> LinkedList&lt;&gt;();
        queue.add(&quot;First&quot;);
        queue.add(&quot;Second&quot;);
        queue.add(&quot;Third&quot;);
        queue.add(&quot;Fourth&quot;);
        String s;
        <b>while</b> ((s = queue.poll()) != <b>null</b>) {
            System.out.print(s + &quot; &quot;); // First Second Third Fourth
        }
    }

}</pre>
</blockquote>
<p>Класс <code>PriorityQueue</code> упорядочивает элементы в соответствии с компаратором (объектом класса, реализующим интерфейс <code>Comparator)</code>, заданным в конструкторе в качестве параметра. Если объект создать с помощью конструктора без параметров, элементы будут упорядочены в естественном порядке (для чисел - по возрастанию, для строк - по алфавиту). Например:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.PriorityQueue;
<b>import</b> java.util.Queue;

<b>public class</b> PriorityQueueTest {
 
    <b>public static void</b> main(String[] args) {
        Queue&lt;String&gt; queue = <b>new</b> PriorityQueue&lt;&gt;();
        queue.add(&quot;First&quot;);
        queue.add(&quot;Second&quot;);
        queue.add(&quot;Third&quot;);
        queue.add(&quot;Fourth&quot;);
        String s;
        <b>while</b> ((s = queue.poll()) != <b>null</b>) {
            System.out.print(s + &quot; &quot;); // First Fourth Second Third
        }
    }

}
</pre>
</blockquote>
<p>Интерфейс <code>Deque</code> (дек, double-ended-queue) предоставляет возможность добавлять и удалять элементы с обоих концов. Методы, объявленные в этом интерфейсе, представлены в следующей таблице:</p>
<div>
  <table class="simple" width="60%" border="1" cellspacing="0" cellpadding="5">
    <tr>
      <th width="30%">Тип операции</th>
      <th width="35%">Работа с первым элементом</th>
      <th width="35%">Работа с последним элементом</th>
    </tr>
    <tr>
      <td width="30%">Добавление</td>
      <td width="35%"><code>addFirst(e)<br>
        offerFirst(e)</code></td>
      <td width="35%"><code>addLast(e)<br>
        offerLast(e)</code></td>
    </tr>
    <tr>
      <td width="30%">Удаление с получением элемента</td>
      <td width="35%"><code>removeFirst()<br>
        pollFirst()</code></td>
      <td width="35%"><code>removeLast()<br>
        pollLast()</code></td>
    </tr>
    <tr>
      <td width="30%">Получение элемента без удаления</td>
      <td width="35%"><code>getFirst()<br>
        peekFirst()</code></td>
      <td width="35%"><code>getLast()<br>
        peekLast()</code></td>
    </tr>
  </table>
</div>
<p>Каждая из пар представляет соответственно функцию, генерирующую исключение, и функцию, возвращающую специальное значение. Имеются также методы, позволяющие удалить первое или последнее вхождение заданного элемента (<code>removeFirstOccurence()</code> и <code>removeLastOccurence()</code> соответственно).</p>
<p>Для реализации интерфейса можно использовать специальный класс <code>ArrayDeque</code>, либо связный список (<code>LinkedList</code>).</p>
<p><i>Стек</i> представляет собой структуру данных, организованную по принципу &quot;последний пришёл - первый вышел&quot; (LIFO, last in - first out). Возможны три операции со стеком: добавление элемента (push), удаление элемента (pop) и чтение головного элемента (peek).</p>
<p>В JRE 1.1 стек представлен классом <code>Stack</code>. Например:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.Stack;

<b>public class</b> StackTest {
  
    <b>public static void</b> main(String[] args) {
        Stack&lt;String&gt; stack = <b>new</b> Stack&lt;&gt;();
        stack.push(&quot;First&quot;);
        stack.push(&quot;Second&quot;);
        stack.push(&quot;Third&quot;);
        stack.push(&quot;Fourth&quot;);
        String s;
        <b>while</b> (!stack.isEmpty()) {
            s = stack.pop();
            System.out.print(s + &quot; &quot;); // Fourth Third Second First
        }
    }

}</pre>
</blockquote>
<p>Этот класс в настоящее время не рекомендован к использованию. Вместо него можно использовать интерфейс <code>Deque</code>, который объявляет аналогичные методы. Например:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.ArrayDeque;
<b>import</b> java.util.Deque;

<b>public class</b> AnotherStackTest {

    <b>public static void</b> main(String[] args) {
        Deque&lt;String&gt; stack = <b>new</b> ArrayDeque&lt;&gt;();
        stack.push(&quot;First&quot;);
        stack.push(&quot;Second&quot;);
        stack.push(&quot;Third&quot;);
        stack.push(&quot;Fourth&quot;);
        String s;
        <b>while</b> (!stack.isEmpty()) {
            s = stack.pop();
            System.out.print(s + &quot; &quot;); // Fourth Third Second First
        }
    }

}
</pre>
</blockquote>
<p>Стеки часто используются в различных алгоритмах. В частности, с помощью стека часто можно избавиться от рекурсии.</p>
<h3>1.5 Статические методы класса Collections. Алгоритмы </h3>
<h4>1.5.1 Создание специальных контейнеров с использованием класса Collections</h4>
<p>Как класс <code>Arrays</code> для массивов, для коллекций существует вспомогательный класс <code>Collections</code>. Этот класс предоставляет ряд статических функций для работы с коллекциями, в частности со списками. Большая группа функций предназначена для создания коллекций различных типов. Следующий пример демонстрирует создание списков и просто некоторой коллекции с помощью статических методов класса <code>Collections</code>, соответственно, пустого списка, &quot;одиночки&quot; и немодифицируемого списка из обычного:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.*;

<b>public</b> <b>class</b> CollectionsCreationDemo {
    <b>public</b> <b>static</b> <b>void</b> main(String[] args) {
        List&lt;Integer&gt; emptyList = Collections.emptyList();
        System.out.println(emptyList); // []
        List&lt;Integer&gt; singletonList = Collections.singletonList(10);
        System.out.println(singletonList); // [10]
        List&lt;Integer&gt; list = <b>new</b> ArrayList&lt;&gt;(Arrays.&lt;Integer&gt;asList(1, 2, 3));
        List&lt;Integer&gt; unmodifiableList = Collections.unmodifiableList(list);
        Collection&lt;Integer&gt; collection = Collections.unmodifiableCollection(list);
    }
}</pre>
</blockquote>
<p>Все приведенные выше функции создают немодифицируемые наборы данных. </p>
<p>Аналогично работают методы, создающие соответствующие множества - <code>emptySet()</code>, <code>singleton()</code>, <code>unmodifiableSet()</code>.</p>
<p>Имеется также возможность создания коллекций, осуществляющих проверку типов во время выполнения программы и недопущение добавления элементов несоответсвтующего типа. Это соответственно методы <code>checkedCollection<code>, </code>checkedList()</code>, <code>checkedSet()</code>, <code>checkedSortedSet()</code>, <code>checkedMap()</code>, <code>checkedSortedMap()</code>, создающие проверяемые коллекции из обычных. </p>
<p>Имеются методы получения &quot;синхронизированных&quot; коллекций, использующихся в многопоточном окружении.</p>
<h4>1.5.2 Алгоритмы</h4>
<p>Под <em>алгоритмом</em> в библиотеке коллекций следует понимать некоторую функцию, реализующую работу с коллекцией (получение некоторого результата либо преобразование элементов колекции). В Java Collections API эта функция как правило, статическая и обобщенная.</p>
<p> Как и класс <code>Arrays</code>, класс <code>Collections</code> содержит реализацию статических функций <code>sort()</code> и <code>fill()</code>.Кроме того, есть большое количество статических функций, которые позволяют обрабатывать списки без применения циклов. Это, например, такие функции, как <code>max()</code> (поиск максимального элемента), <code>min()</code> (поиск минимального элемента), <code>indexOfSubList()</code> (поиск индекса первого полного вхождения подсписков в список), <code>frequency()</code> (определение количества раз вхождения определенного элемента в список), <code>reverse()</code> (замена порядка элементов на противоположный), <code>rotate()</code> (циклический сдвиг списка на заданное количество элементов), <code>shuffle()</code> (&quot;перемешивание&quot; элементов), <code>nCopies()</code> (создание нового списка с определенным количеством одинаковых элементов). Использование этих функции можно проиллюстрировать на следующем примере:</p>
<blockquote>
  <pre>List&lt;Integer&gt; a = Arrays.asList(0, 1, 2, 3, 3, -4);
System.out.println(Collections.max(a)); // 3 
System.out.println(Collections.min(a)); // -4
System.out.println(Collections.frequency(a, 2)); // 1 раз
System.out.println(Collections.frequency(a, 3)); // 2 раза
Collections.reverse(a);   // меняем порядок элементов на противоположный
System.out.println(a);    // [-4, 3, 3, 2, 1, 0]
Collections.rotate(a, 3); // сдвигает список циклически на 3 элемента
System.out.println(a);    // [2, 1, 0, -4, 3, 3]
List&lt;Integer&gt; sublist = Collections.nCopies(2, 3); // Новый список содержит 2 тройки 
System.out.println(Collections.indexOfSubList(a, sublist)); // 4
Collections.shuffle(a);   // &quot;тасуем&quot; элементы
System.out.println(a);    // элементы в произвольном порядке
Collections.sort(a);
System.out.println(a);    // [-4, 0, 1, 2, 3, 3]
List&lt;Integer&gt; b = new ArrayList&lt;Integer&gt;(a);
Collections.fill(b, 8);
System.out.println(b);    // [8, 8, 8, 8, 8, 8]
Collections.copy(b, a);
System.out.println(b);    // [-4, 0, 1, 2, 3, 3]
System.out.println(Collections.binarySearch(b, 2)); // 3
Collections.swap(b, 0, 5);
System.out.println(b);    // [3, 0, 1, 2, 3, -4]
Collections.replaceAll(b, 3, 10);
System.out.println(b);    // [10, 0, 1, 2, 10, -4]
</pre>
</blockquote>
<p>Класс <code>Collections</code> также предоставляет методы специально для работы со списками, получение первого и последнего индекса начала вхождения подсписка в список (<code>indexOfSubList()</code>, <code>lastIndexOfSubList()</code>) и т. д.</p>
<p>Начиная с версии JDK 1.8, некоторые алгоритмы реализованы как нестатические методы интерфейса <code>Collection</code> и других базовых интерфейсов с реализацией по умолчанию. Например, <code>removeIf(Predicate&lt;?&nbsp;<strong>super</strong>&nbsp;E&gt;&nbsp;filter)</code>, <code>replaceAll(UnaryOperator&lt;E&gt;&nbsp;operator)</code>, <code>sort(Comparator&nbsp;&lt;?&nbsp;super&nbsp;E&gt;&nbsp;c)</code>.</p>
<h3>1.6 Ассоциативные массивы</h3>
<p><i>Ассоциативные массивы</i> могут хранить пары ссылок на объекты. Ассоциативные массивы тоже являются обобщенными типами. Ассоциативные массивы в Java представлены обобщенным интерфейсом <code>Map</code>, который реализован, в частности, классом <code>HashMap</code>. Интерфейс <code>SortedMap</code>, производный от <code>Map</code>, требует упорядоченного по ключу хранения пар. Интерфейс <code>NavigableMap</code>, появившийся в java SE 6, расширяет <code>SortedМap</code> и добавляет новые возможности поиска по ключу. Этот интерфейс реализован классом <code>TreeMap</code>.</p>
<p>Каждое значение (объект), которое хранится в ассоциативном массиве, связывается с конкретным значением другого объекта (ключа). Метод <code>put(key, value)</code> добавляет значение (<code>value</code>) и ассоциирует с ним ключ (<code>key</code>). Если ассоциативный массив ранее содержал пары с указанным ключом, новое значение замещает старое. Метод <code>put()</code> возвращает предыдущее значение, связанное с ключом, или <code><b>null</b></code>, если ключ отсутствовал. Метод <code>get(Object key)</code> возвращает объект по заданному ключу. Для проверки нахождения ключа и значения применяются методы <code>containsKey()</code> и <code>containsValue()</code>.</p>
<p>На логическом уровне можно представить ассоциативный массив через три вспомогательных коллекции:</p>
<ul>
  <li><code>keySet</code> <code>-</code> множество значений ключа; </li>
  <li><code>values</code> <code>-</code> список значений; </li>
  <li><code>entrySet</code> <code>-</code> множество пар ключ-значение.</li>
</ul>
<p>Через соответствующие функции <code>keySet()</code>, <code>values()</code> и <code>entrySet()</code> можно осуществлять определенные действия, в первую очередь последовательное прохождение элементов.</p>
<p>В приведенном ниже примере вычисляется количество вхождений различных слов в предложение. Слова и соответствующие количества хранятся в ассоциативном массиве. Использование класса <code>TreeMap</code> гарантирует алфавитный порядок слов (ключей).</p>
<blockquote>
  <pre><b>import</b> java.util.*;

<b>public class</b> WordsCounter {
    <b>public static void</b> main(String[] args) {
        Map&lt;String, Integer&gt; m = <b>new</b> TreeMap&lt;String, Integer&gt;();
        String s = &quot;the first men on the moon&quot;;
        StringTokenizer st = <b>new</b> StringTokenizer(s);
        <b>while</b> (st.hasMoreTokens()) {
            String word = st.nextToken();
            Integer count = m.get(word);
            m.put(word, (count == <b>null</b>) ? 1 : count + 1);
        }
        <b>for</b> (String word : m.keySet()) {
            System.out.println(word + &quot; &quot; + m.get(word));
        }
    }

}</pre>
</blockquote>
<p>Использование <code>keySet()</code> предусматривает отдельный поиск каждого значения по ключу. Более рекомендуемым является обход ассоциативного массива через множество пар:</p>
<pre><b>    for</b> (Map.Entry&lt;?, ?&gt; entry : m.entrySet()) {
        System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());
    }    </pre>
<p>Здесь метод <code>entrySet()</code> позволяет получить представление ассоциативного массива в виде коллекции <code>Set</code>.</p>
<p>Порядок сортировки элементов <code>TreeMap </code> также можно изменить, указав в качестве параметра конструктора <code>TreeMap</code> объект класса, реализующий интерфейс <code>Comparator, </code>либо задав ключ как объект класса, реализующий интерфейс <code>Comparable</code>:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.*;

<b>public class</b> TreeMapKey <b>implements</b> Comparable&lt;TreeMapKey&gt; {
    String name;

    <b>public</b> String getName() {
        <b>return</b> name;
    }

    <b>private</b> TreeMapKey(String name) {
        <b>super</b>();
        <b>this</b>.name = name;
    }

    @Override
    <b>public int</b> compareTo(TreeMapKey o) {
        <b>return</b> name.substring(getName().indexOf(&quot; &quot;)).trim()
          .compareToIgnoreCase(o.getName().substring(o.getName().indexOf(&quot; &quot;)).trim());
    }

    <b>public static void</b> main(String args[]) {
        TreeMap&lt;TreeMapKey, Integer&gt; tm = <b>new</b> TreeMap&lt;TreeMapKey, Integer&gt;();
        tm.put(<b>new</b> TreeMapKey(&quot;Петр Иванов&quot;), <b>new</b> Integer(1982));
        tm.put(<b>new</b> TreeMapKey(&quot;Иван Петров&quot;), <b>new</b> Integer(1979));
        tm.put(<b>new</b> TreeMapKey(&quot;Василий Сидоров&quot;), <b>new</b> Integer(1988));
        tm.put(<b>new</b> TreeMapKey(&quot;Сидор Васильев&quot;), <b>new</b> Integer(1980));
        <b>for</b> (Map.Entry&lt;TreeMapKey, Integer&gt; me : tm.entrySet()) {
            System.out.print(me.getKey().getName() + &quot;: &quot;);
            System.out.println(me.getValue());
        }
        System.out.println();
    }

}</pre>
</blockquote>
<p>Класс <code>WeakHashMap&lt;K,V&gt;</code> позволяет сборщику мусора удалять из ассоциативного массива значения по ключу, ссылка на который вышла из области видимости приложения. Класс <code>LinkedHashMap&lt;K,V&gt;</code> запоминает порядок добавления объектов в ассоциативный массив и образует при этом двусвязный список ключей.</p>
<p>Класс <code>Hashtable</code> - одна из реализаций интерфейса <code>Map</code>. <code>Hashtable</code> кроме размера имеет емкость (размер буфера, выделенного под элементы массива). Кроме этого он характеризуется показателем загруженности - долей буфера, после заполнения которой емкость автоматически увеличивается. Конструктор <code>Hashtable()</code> без параметров создает пустой объект с емкостью в 101 элемент и показателем загруженности 0,75.</p>
<p>Класс <code>Properties</code>, производный от <code>Hashtable</code> вместо пар произвольных объектов сохраняет пару строк. Если в конкретной задаче и ключи и значения элементов ассоциативного массива имеют тип <code>String</code>, удобнее воспользоваться классом <code>Properties</code>. В классе <code>Properties</code> определены методы <code>getProperty(String key)</code> и <code>setProperty(String key, String value)</code>.</p>
<h3>1.7 Внутренняя организация множеств и ассоциативных контейнеров</h3>
<h4>1.7.1 Реализация множеств и ассоциативных контейнеров с использованием хеширования</h4>
<p>Для хранения данных в <code>HashSet</code> и <code>HashMap</code> используется хеширование. </p>
<p>Контейнеры, построенные с использованием хеширования, не гарантируют определенного порядка хранения элементов, однако обеспечивают относительно высокую эффективность поиска, добавления и хранения элементов</p>
<p>Организация хранения данных в классах <code>HashSet</code> и <code>HashMap</code> аналогична. Рассмотрим организацию представления данных на примере контейнера <code>HashMap</code>. Вложенный класс представляет <code>Entry</code> пару ключ-значение:</p>
<blockquote>
  <pre><b>static</b> <b>class</b> Entry&lt;K,V&gt; <b>implements</b> Map.Entry&lt;K,V&gt; {
    <b>final</b> K key;
    V value;
    Entry&lt;K,V&gt; next;
    <b>int</b> hash;
    // ...Далее следует конструктор и ряд вспомогательных методов
}</pre>
</blockquote>
<p>Экземпляры данного класса хранятся в массиве. По умолчанию массив рассчитан на хранение 16 элементов, но потом его размеры могут меняться. Элементы этого массива именуются <i>корзинами</i>, так как они хранят ссылки на списки элементов (поле <code>next</code>). При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. При этом значение хеш-кода &quot;проецируется&quot; на массив с учетом его реальных размеров. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется. </p>
<p>Эффективность операций добавления, поиска и удаления зависит от реализации хеш-функции. Если она выдает постоянное значение, контейнер превращается в связный список с низкой эффективностью.</p>
<h4>1.7.2 Реализация контейнеров на базе двоичных деревьев</h4>
<p><i>Двоичное дерево</i> представляет собой древовидную структуру данных (граф без циклов), в которой каждая вершина (узел) имеет не более двух потомков (наследников). Их называют соответственно левым и правым наследником. В свою очередь, они могут выступать как вершины поддеревьев. Можно говорить о левом и правом поддереве. </p>
<p>Двоичное дерево может быть использовано для упорядоченного по некоторому признаку хранения объектов (упорядочение по <i>ключу</i>). В этом случае говорят о так называемом <i>двоичном дереве поиска</i>, удовлетворяющем следующим правилам:</p>
<ul>
  <li>левое и правое поддеревья также являются двоичными деревьями поиска;</li>
  <li>у всех узлов левого поддерева некоторого узла значения ключей данных меньше, нежели значение ключа у данного узла;</li>
  <li>у всех узлов правого поддерева того же узла значения ключей данных не меньше, нежели значение ключа у рассматриваемого узла.</li>
</ul>
<p>Обычно для двоичных деревьев поиска реализуют следующие основные операции</p>
<ul>
  <li>добавление элемента</li>
  <li>получение (поиск) элемента</li>
  <li>удаление элемента (узла)</li>
  <li>обход дерева</li>
</ul>
<p>Двоичное дерево называется <i>идеально сбалансированным</i>, если для каждой его вершины количество вершин в левом и правом поддереве различаются не более чем на 1. У несбалансированного дерева это правило не соблюдается. Простейшая реализация дерева дает несбалансированное дерево. В зависимости от порядка добавления элементов дерево может быть сбалансированным или совсем несбалансированным. Допустим, что двоичное дерево хранит целые значения. Если числа от 1 до 7 добавлять в определенном порядке (например, 4, 2, 3, 1, 6, 7, 5), может получиться идеально сбалансированное дерево:</p>
<div align="center"><img src="Images/3_03_tree1.png" width="293" height="138"></div>
<p>Если же числа добавлять в порядке возрастания, получится сильно несбалансированное дерево:</p>
<div align="center"><img src="Images/3_03_tree2.png" width="298" height="321"></div>
<p>Можно говорить о разной степени сбалансированности. Несбалансированность снижает производительность при поиске элемента. Вместе с тем, создание идеально сбалансированных деревьев обуславливает вычислительные трудности при добавлении и удалении. В реальной практике чаще всего используют частично сбалансированные деревья. </p>
<p>Так называемое красно-черное дерево &#8211; это самобалансирующееся двоичное дерево поиска, позволяющее эффективно реализовать основные операции (добавление, поиск и удаление). Каждому узлу дерева ставится в соответствие цвет &#8211; красный или черный. К каждому узлу добавляются фиктивные листовые узлы, не содержащие данных. Также накладываются дополнительные требования:</p>
<ul>
  <li>Корень дерева должен быть черным</li>
  <li>Все листовые узлы &#8211; черные</li>
  <li>Оба потомка каждого красного узла — черные</li>
  <li>Всякий простой путь от данного узла до любого листового узла, являющегося его потомком, содержит одинаковое число черных узлов</li>
</ul>
<p>Например, можно получить такое красно-черное дерево (с сайта ru.wikipedia.org):</p>
<div align="center"><img src="Images/3_03_tree3.png" width="568" height="285"></div>
<p>При добавлении нового узла (всегда красного) иногда приходится перекрашивать дерево и &quot;оборачивать&quot; его. Добавление вершин с учетом ограничений и &quot;оборачивание&quot; с переносом узлов делает дерево самосбалансированным. Красно-черные деревья используются для построения контейнеров <code>TreeSet</code> и <code>TreeMap</code>.</p>
<h3>1.8 Создание собственных контейнеров</h3>
<p>Несмотря на большое количество стандартных контейнерных классов, иногда возникает потребность в создании собственных контейнеров. Это могут быть, например, сложные деревья, более гибкие списки, специализированные коллекции элементов и т.д.
<p>В некоторых случаях необходимо только обходить элементы некоторой последовательности с помощью альтернативной формы цикла <b><code>for</code></b>. Для этого достаточно реализовать интерфейс <code>Iterable&lt;&gt;</code>. Он требует реализации функции, возвращающей итератор. Чаще всего для реализации итератора создают внутренний нестатический класс. В следующем примере создается класс &quot;Предложение&quot; с итератором, который перемещается по отдельным словам. В результате программа выводит слова введенного предложения в отдельных строках:
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.Iterator;
<b>import</b> java.util.Scanner;
<b>import</b> java.util.StringTokenizer;

<b>public</b> <b>class</b> Sentence <b>implements</b> Iterable&lt;String&gt; {
    <b>private</b> <b></b>String text;

    <b>public</b> Sentence(String text) {
    <b>    this</b>.text = text;
    }

    <b>private</b> <b>class</b> WordsIterator <b>implements</b> Iterator&lt;String&gt; {
        StringTokenizer st = <b>new</b> StringTokenizer(text);

        @Override
        <b>public</b> <b>boolean</b> hasNext() {
            <b>return</b> st.hasMoreTokens();
        }

        @Override
        <b>public</b> String next() {
            <b>return</b> st.nextToken();
        }

        @Override
        <b>public</b> <b>void</b> remove() {
            <b>throw</b> <b>new</b> RuntimeException(&quot;Not implemented!&quot;);     
        }

    }

    <b>public</b> Iterator&lt;String&gt; iterator() {
        <b>return</b> <b>new</b> WordsIterator();
    }

    <b>public</b> <b>static</b> <b>void</b> main(String[] args) {
        String text = <b>new</b> Scanner(System.in).nextLine();
        Sentence sentence = <b>new</b> Sentence(text);
        <b>for</b> (String word : sentence) {
            System.out.println(word);
        }
    }

}</pre>
</blockquote>
<p> В большинстве случаев для создания итераторов необходимо описание так называемого курсора &#8211; переменной, которая ссылается на текущий элемент последовательности. В этом случае реализация метода <code>next()</code> предполагает перемещение курсора и возвращение ссылки на текущий элемент. Например:</p>
<blockquote>
  <pre><b>public</b> <b>class</b> SomeArray&lt;E&gt; <b>implements</b> Iterable&lt;E&gt; {
    <b>private</b> E[] arr;

    ...

    <b>private</b> <b>class</b> InnerIterator <b>implements</b> Iterator&lt;E&gt; {
        <b>int</b> cursor = -1;

        @Override
        <b>public</b> <b>boolean</b> hasNext() {
            <b>return</b> cursor &lt; arr.length - 1;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        <b>public</b> E next() {   
            <b>return</b> arr[++cursor];
        }

        @Override
        <b>public</b> <b>void</b> remove() {
            <b>throw</b> <b>new</b> RuntimeException(&quot;Not implemented&quot;);   
        }
    }

    @Override
  <b>  public</b> Iterator&lt;E&gt; iterator() {
        <b>return</b> <b>new</b> InnerIterator();
    }
  ...
}
</pre>
</blockquote>
<p>Для создания полноценных собственных контейнеров лучше всего воспользоваться имеющимися абстрактными классами. Это <code>AbstractCollection&lt;E&gt;</code>, <code>AbstractList&lt;E&gt;</code>, <code>AbstractMap&lt;K,V&gt;</code>, <code>AbstractQueue&lt;E&gt;</code>, <code>AbstractSet&lt;E&gt;</code>, а также некоторые абстрактные вспомогательные классы. Например, для того, чтобы создать собственный список (только для чтения), формально достаточно перекрыть два абстрактных метода &#8211; <code>get()</code> и <code>size()</code>. При работе со списками только для чтения методы типа <code>add()</code>, <code>set()</code>, <code>remove()</code> и прочие, предназначенные для изменения списка, генерируют исключение <code>UnsupportedOperationException()</code>. В следующем примере создается простейший список (только для чтения):</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.AbstractList;

<b>public</b> <b>class</b> MyList <b>extends</b> AbstractList&lt;String&gt; {
    String[] arr = { &quot;one&quot;, &quot;two&quot;, &quot;three&quot; };

    @Override
    <b>public</b> String get(<b>int</b> index) {
        <b>return</b> arr[index];
    }

    @Override
    <b>public</b> <b>int</b> size() {
        <b>return</b> arr.length;
    }

    <b>public</b> <b>static</b> <b>void</b> main(String[] args) {
        MyList list = <b>new</b> MyList();
        <b>for</b> (String elem : list) {
            System.out.println(elem); {
        }
        System.out.println(list.subList(0, 2));  // [one, two]
        System.out.println(list.indexOf(&quot;two&quot;)); // 1
        list.add(&quot;four&quot;); // Исключение &quot;UnsupportedOperationException&quot;
    }
}</pre>
</blockquote>
<p>Для того чтобы реализовать контейнер для чтения и записи, необходимо перекрыть соответствующие методы. В примере 2.10 реализован соответствующий контейнер. </p>
<h2>2 Примеры программ</h2>
<h3>2.1 Сумма элементов типа Double<b></b></h3>
<p>Следующая программа читает действительные числа, которые вводит пользователь, заносит их в список и находит сумму.</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;
<b>
import</b> java.util.*;
<b>
public</b> <b>class</b> SumOfElements {

    <b>public</b> <b>static</b> <b>void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        List&lt;Double&gt; a = <b>new</b> ArrayList&lt;Double&gt;();
        <b>double</b> d = 1; // начальное значение не должно быть 0
        <b>while</b> (d != 0) {
            d = scanner.nextDouble();
            a.add(d);
        }
        <b>double</b> sum = 0;
        <b>for</b> (<b>double</b> x : a) { // неявный итератор
            sum += x;
        }
        System.out.println(&quot;Сумма: &quot; + sum);
    }

}    </pre>
</blockquote>
<p>Чтение чисел с клавиатуры осуществляется до тех пор, пока пользователь не введет значение 0.</p>
<h3>2.2 Индекс максимального элемента</h3>
<p>Следующая программа находит номер максимального элемента в списке целых чисел. Для заполнения списка можно использовать массив с начальными значениями элементов. Массив неявно создается во время выполнения функции <code>asList()</code>.</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;
<b>
import</b> java.util.*;
<b>
public</b> <b>class</b> MaxElement {

    <b>public</b> <b>static</b> <b>void</b> main(String[] args) {
        List&lt;Integer&gt; a = Arrays.asList(2, 3, -7, 8, 11, 0);
        <b>int</b> indexOfMax = 0;
        <b>for</b> (<b>int</b> i = 1; i &lt; a.size(); i++) {
            <b>if</b> (a.get(i) &gt; a.get(indexOfMax)) {
                indexOfMax = i;
            }
        }
        System.out.println(indexOfMax + &quot; &quot; + a.get(indexOfMax));
    }

}</pre>
</blockquote>
<h3>2.3 Реализация класса для представления массива точек с помощью списка</h3>
<p>Еще одна возможная реализация представления массива точек, определенного в предыдущем занятии, основана на использовании списка точек. В проекте, содержащем класс<code> AbstractArrayOfPoints</code>, создаем новый пакет и в нем - класс <code>ListOfPointObjects</code>. Для обеспечения возможности использования классов <code>AbstractArrayOfPoints</code> и <code>Point</code> добавляем соответствующие утверждения импорта.</p>
<p>Исходный код класса будет иметь следующий вид:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.ArrayList;
<b>import</b> lesson105.AbstractArrayOfPoints;
<b>import</b> lesson105.Point;

<b>public</b> <b>class</b> ListOfPointObjects <b>extends</b> AbstractArrayOfPoints {
    ArrayList&lt;Point&gt; p = <b>new</b> ArrayList&lt;&gt;();

    @Override
    <b>public</b> <b>void</b> setPoint(<b>int</b> i, <b>double</b> x, <b>double</b> y) {
        p.get(i).setPoint(x, y);
    }

    @Override
    <b>public</b> <b>double</b> getX(<b>int</b> i) {
        <b>return</b> p.get(i).getX();
    }

    @Override
    <b>public</b> <b>double</b> getY(<b>int</b> i) {
        <b>return</b> p.get(i).getY();
    }

    @Override
    <b>public</b> <b>int</b> count() {
        <b>return</b> p.size();
    }

    @Override
    <b>public</b> <b>void</b> addPoint(<b>double</b> x, <b>double</b> y) {
        p.add(<b>new</b> Point(x, y));
    }

    @Override
    <b>public</b> <b>void</b> removeLast() {
        p.remove(count() - 1);
    }

    <b>public</b> <b>static</b> <b>void</b> main(String[] args) {
        <b>new</b> ListOfPointObjects().test();
    }
}
</pre>
</blockquote>
<p>Результаты должны быть идентичными полученным ранее.</p>
<h3>2.4 Буквы предложения в алфавитном порядке<b></b></h3>
<p>В приведенном ниже примере вводится предложение и выводятся все различные буквы предложения (не считая разделителей) в алфавитном порядке:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.*;

<b>public class</b> Sentence {
  
    <b>public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        // Функция nextLine() читает строку до конца:
        String sentence = scanner.nextLine();
        // Создаем множество разделителей:
        Set&lt;Character&gt; delimiters = <b>new</b> HashSet&lt;Character&gt;(
            Arrays.asList(' ', '.', ',', ':', ';', '?', '!', '-', '(', ')', '\&quot;'));
        // Создаем множество букв:
        Set&lt;Character&gt; letters = <b>new</b> TreeSet&lt;Character&gt;();
        // Добавляем все буквы кроме разделителей:
        <b>for</b> (<b>int</b> i = 0; i &lt; sentence.length(); i++) {
            <b>if</b> (!delimiters.contains(sentence.charAt(i))) {
                letters.add(sentence.charAt(i));
            }
        }
        System.out.println(letters);
    }
  
}</pre>
</blockquote>
<h3>2.5 Произведение вводимых чисел<b></b></h3>
<p>В приведенном ниже примере вводятся целые числа, выводятся в порядке убывания, а также вычисляется их произведение. Ввод завершается нулем:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.*;

<b>public class</b> Product {

    <b>public static void</b> main(String[] args) {
        Queue&lt;Integer&gt; queue = <b>new</b> PriorityQueue&lt;&gt;(100, <b>new</b> Comparator&lt;Integer&gt;() {
            @Override
            <b>public int</b> compare(Integer i1, Integer i2) {
                <b>return</b> -Double.compare(i1, i2);
            }
        });
        Scanner scanner = <b>new</b> Scanner(System.in);
        Integer k;
        <b>do</b> {
            k = scanner.nextInt();
            <b>if</b> (k != 0) {
                queue.add(k);
            }
        }
        <b>while</b> (k != 0);
        <b>int</b> p = 1;
        <b>while</b> ((k = queue.poll()) != <b>null</b>) {
            p *= k;
            System.out.print(k + &quot; &quot;); 
        }
        System.out.println();
        System.out.println(p);
    }

}
</pre>
</blockquote>
<h3>2.6 Проверка корректности скобок<b></b></h3>
<p>В приведенном ниже примере вводится строка и проверяется корректность открытия и закрытия скобок:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.ArrayDeque;
<b>import</b> java.util.Deque;
<b>import</b> java.util.Scanner;

<b>public class</b> Brackets {

    <b>public static void</b> main(String[] args) {
        <b>try</b> {
            Deque&lt;Character&gt; brackets = <b>new</b> ArrayDeque&lt;&gt;();
            String s = <b>new</b> Scanner(System.in).nextLine();
            <b>for</b> (<b>int</b> i = 0; i &lt; s.length(); i++) {
                <b>if</b> (s.charAt(i) == '(') {
                    brackets.push('(');
                }
                <b>if</b> (s.charAt(i) == ')')
                  brackets.pop();
            }
      <b>      if</b> (!brackets.isEmpty()) {
        <b>        throw new</b> Exception();
            }
            System.out.println(&quot;Строка корректна&quot;);
        }
        <b>catch</b> (Exception e) {
            System.out.println(&quot;Строка некорректна&quot;);
        }
    }

}</pre>
</blockquote>
<p>Достоинством приведенной выше реализации является централизация диагностики ошибки. Недостаток - использование механизма исключений, который может снизить эффективность работы программы. Можно предложить другой вариант, не требующий обработки исключений:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.ArrayDeque;
<b>import</b> java.util.Deque;
<b>import</b> java.util.Scanner;

<b>public class</b> BracketsWithoutExceptions {

    <b>public static void</b> main(String[] args) {
        Deque&lt;Character&gt; brackets = <b>new</b> ArrayDeque&lt;&gt;();
        String s = <b>new</b> Scanner(System.in).nextLine();
        <b>for</b> (<b>int</b> i = 0; i &lt; s.length(); i++) {
            <b>if</b> (s.charAt(i) == '(') {
                brackets.push('(');
            }
          <b>  if</b> (s.charAt(i) == ')') {
                <b>if</b> (brackets.poll() == <b>null</b>) {
                    System.out.println(&quot;Строка некорректна: &quot; + 
                                  &quot;лишние закрывающиеся скобки&quot;);
                    <b>return</b>;
                }
            }
        }
        <b>if</b> (!brackets.isEmpty()) {
            System.out.println(&quot;Строка некорректна: не все скобки закрыты&quot;);
        }
        <b>else {</b>
            System.out.println(&quot;Строка корректна&quot;);
        }
    }

}
</pre>
</blockquote>
<p>Последний вариант позволяет отдельно диагностировать различные ошибки.</p>
<h3>2.7 Данные о странах в ассоциативном массиве</h3>
<p>Данные о странах (название и территория) можно хранить в ассоциативном массиве. Вывод осуществляется по алфавиту стран:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.Map;
<b>import</b> java.util.SortedMap;
<b>import</b> java.util.TreeMap;

<b>public class</b> Countries {

    <b>public static void</b> main(String[] args) {
        SortedMap&lt;String, Double&gt; countries = <b>new</b> TreeMap&lt;&gt;();
        countries.put(&quot;Украина&quot;, 603700.0);
        countries.put(&quot;Германия&quot;, 357021.0);
        countries.put(&quot;Франция&quot;, 547030.0);
        <b>for</b> (Map.Entry&lt;?, ?&gt; entry : countries.entrySet())
            System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());  
    }

}</pre>
</blockquote>
<h3>2.8 Создание однонаправленного списка<b></b></h3>
<p>В приведенном ниже примере создается и заполняется однонаправленный список:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>public</b> <b>class</b> SinglyLinkedList&lt;E&gt; {

    <b>private</b> <b>class</b> Node {
        E    data;
        Node next;
        Node(E data, Node next) {
            <b>this</b>.data = data;
            <b>this</b>.next = next;
        }
    }

    <b>private</b> Node first = <b>null</b>;
    <b>private</b> Node last  = <b>null</b>;
    <b>private</b> <b>int</b>  count = 0;

    <b>public</b> <b>void</b> add(E elem) {
        Node newNode = <b>new</b> Node(elem, <b>null</b>);
        <b>if</b> (last == <b>null</b>) {
            first = newNode;
        }
        <b>else</b> {
            last.next = newNode;
        }
        last = newNode;
        count++;
    }

    <b>public</b> <b>void</b> removeFirstOccurrence(E value) {
        // Отдельно проверяем первый элемент
        <b>if</b> (first != <b>null</b> &amp;&amp; first.data.equals(value) { 
            first = first.next; 
            count--; 
        }
        <b>else</b> {
            Node link = first;
            <b>while</b> (link.next != <b>null</b>) {
                <b>if</b> (link.next.data.equals(value)) {
                    link.next = link.next.next;
                    count--;
                }
                <b>if</b> (link.next == <b>null</b>) {
                    last = link;
                    <b>break</b>; // удалили последний элемент
                }
                link = link.next;
            }
        }
    }

    <b>public</b> <b>final</b> <b>int</b> size() {
        <b>return</b> count;
    }

    @Override
    <b>public</b> String toString() {
        String s = &quot;size = &quot; + size() + &quot;\n[&quot;;
        Node link = first;
        <b>while</b> (link != <b>null</b>) {
            s += link.data;
            link = link.next;
            <b>if</b> (link != <b>null</b>) {
                s += &quot;, &quot;;
            }
        }
        s += &quot;]\n&quot;;
        <b>return</b> s;
    }

    <b>public</b> <b>static</b> <b>void</b> main(String[] args) {
        SinglyLinkedList&lt;Integer&gt; list = <b>new</b> SinglyLinkedList&lt;&gt;();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        System.out.println(list);
        // Удаляем средний элемент
        list.removeFirstOccurrence(3); 
        System.out.println(list);
        // Удаляем первый элемент:
        list.removeFirstOccurrence(1);
        System.out.println(list);
        // Удаляем последний элемент:
        list.removeFirstOccurrence(4);
        System.out.println(list);
    }
}</pre>
</blockquote>
<h3>2.9 Создание двоичного дерева<b></b></h3>
<p>В приведенном ниже примере создается и заполняется обычное (несбалансированное) двоичное дерево, содержащее пары целое / строка:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>public</b> <b>class</b> BinaryTree {

    // Класс для представления узла
    <b>public</b> <b>static</b> <b>class</b> Node {
        <b>int</b>    key;
        String value;
        Node   leftChild;
        Node   rightChild;
        
        Node(<b>int</b> key, String name) {
            <b>this</b>.key = key;
            <b>this</b>.value = name;
        }

        @Override
        <b>public</b> String toString() {
            <b>return</b> &quot;Key: &quot; + key + &quot; Value:&quot; + value;
        }
    }

  <b>  private</b> Node root;

    <b>public</b> <b>void</b> addNode(<b>int</b> key, String value) {
        // Создаем новый узел:
        Node newNode = <b>new</b> Node(key, value);
        <b>if</b> (root == <b>null</b>) { // первый добавленный узел
            root = newNode;
        }
        <b>else</b> {
            // Начинаем обход:
            Node currentNode = root;
            Node parent;
      <b>      while</b> (<b>true</b>) {
                parent = currentNode;
                // Проверяем ключи:
        <b>        if</b> (key &lt; currentNode.key) {
                    currentNode = currentNode.leftChild;
          <b>          if</b> (currentNode == <b>null</b>) {
                        // Помещаем узел в нужное место:
                        parent.leftChild = newNode;
            <b>            return</b>;
                    }
                }
                <b>else</b> { 
                    currentNode = currentNode.rightChild;
                    <b>if</b> (currentNode == <b>null</b>) {
                        // Помещаем узел в нужное место:
                        parent.rightChild = newNode;
                        <b>return</b>;
                    }
                }
            }
        }
    }

    // Обход узлов в порядке возрастания ключей
    <b>public</b> <b>void</b> traverseTree(Node currentNode) {
    <b>    if</b> (currentNode != <b>null</b>) {
            traverseTree(currentNode.leftChild);
            System.out.println(currentNode);
            traverseTree(currentNode.rightChild);
        }
    }

  <b>  public</b> <b>void</b> traverseTree() {
        traverseTree(root);
    }

    // Поиск узла по ключу
    <b>public</b> Node findNode(<b>int</b> key) {
        Node focusNode = root;
        <b>while</b> (focusNode.key != key) {
            <b>if</b> (key &lt; focusNode.key) {
                focusNode = focusNode.leftChild;
            }
      <b>      else</b> {
                focusNode = focusNode.rightChild;
            }
            // Не нашли:
            <b>if</b> (focusNode == <b>null</b>) {
                <b>return</b> <b>null</b>;
            }
        }
        <b>return</b> focusNode;
    }

    // Тест:
    <b>public</b> <b>static</b> <b>void</b> main(String[] args) {
        BinaryTree continents = <b>new</b> BinaryTree();
        continents.addNode(1, &quot;Европа&quot;);
        continents.addNode(3, &quot;Африка&quot;);
        continents.addNode(5, &quot;Австралия&quot;);
        continents.addNode(4, &quot;Америка&quot;);
        continents.addNode(2, &quot;Азия&quot;);
        continents.addNode(6, &quot;Антарктида&quot;);
        continents.traverseTree();
        System.out.println(&quot;\nКонтинент с ключом 4:&quot;);
        System.out.println(continents.findNode(4));
    }
}</pre>
</blockquote>
<h3>2.10 Создание собственного контейнера<b> на базе списка ArrayList</b></h3>
<p>В приведенном ниже примере реализован класс для представления массива, индексация которого начинается с 1. Необходимо перекрыть все операции, связанные с индексом. Внутри можно использовать <code>ArrayList</code>:</p>
<blockquote>
  <pre><b>package</b> ua.inf.iwanoff.collections;

<b>import</b> java.util.AbstractList;
<b>import</b> java.util.ArrayList;
<b>import</b> java.util.Arrays;
<b>import</b> java.util.Iterator;

@SuppressWarnings(&quot;unchecked&quot;)
<b>public</b> <b>class</b> ArrayFromOne&lt;E&gt; <b>extends</b> AbstractList&lt;E&gt; {
    ArrayList&lt;Object&gt; arr = <b>new</b> ArrayList&lt;&gt;();

    @Override
  <b>  public</b> E <b>get</b>(<b>int</b> index) {
        <b>return</b> (E)arr.get(index - 1);
    }

    @Override
    <b>public</b> <b>int</b> size() {
        <b>return</b> arr.size();
    }

    @Override
    <b>public</b> <b>void</b> add(<b>int</b> index, E element) {
        arr.add(index - 1, element);
    }

    @Override
    <b>public</b> <b>boolean</b> add(E e) {
        <b>return</b> arr.add(e);
    }

    @Override
    <b>public</b> E <b>set</b>(<b>int</b> index, E element) {
        <b>return</b> (E)arr.set(index - 1, element);
    }

    @Override
    <b>public</b> E remove(<b>int</b> index) {
        <b>return</b> (E)arr.remove(index - 1);
    }

    @Override
    <b>public</b> <b>int</b> indexOf(Object o) {
        <b>return</b> arr.indexOf(o) + 1;
    }

    @Override
    <b>public</b> <b>int</b> lastIndexOf(Object o) {
        <b>return</b> arr.lastIndexOf(o) + 1;
    }

    @Override
    <b>public</b> Iterator&lt;E&gt; iterator() {
        <b>return</b> (Iterator&lt;E&gt;)arr.iterator();
    }

    <b>public</b> <b>static</b> <b>void</b> main(String[] args) {
        ArrayFromOne&lt;Integer&gt; a = <b>new</b> ArrayFromOne&lt;&gt;();
        a.add(1);
        a.add(2);
        System.out.println(a.get(1) + &quot; &quot; + a.get(2)); // 1 2
        System.out.println(a.indexOf(2));              // 2
        a.set(1, 3);
        <b>for</b> (Integer k : a) {
            System.out.print(k + &quot; &quot;);                   // 3 2
        }
        System.out.println();
        a.remove(2);
        System.out.println(a);                         // [3]
        a.addAll(Arrays.asList(<b>new</b> Integer[]{ 4, 5 }));
        System.out.println(a.get(3));                  // 5
    }

}</pre>
</blockquote>
<p>Аннотация <code>@SuppressWarnings(&quot;unchecked&quot;)</code> перед классом нужна для подавления предупреждений, связанных с явным приведением типов.</p>
<h2>3 Задания на самостоятельную работу</h2>
<h3>3.1 Реализация массива точек списком вещественных чисел</h3>
<p>Реализовать функциональность абстрактного класса <code>AbstractArrayOfPoints</code>, приведенного в примере предыдущего занятия, через использование списка вещественных чисел. Каждая пара чисел в списке должна соответствовать точке.</p>
<h3>3.2 Слова в алфавитном порядке*</h3>
<p>Ввести предложение и вывести все различные слова предложения в алфавитном порядке. Использовать множество.</p>
<h3>3.3 Среднее арифметическое*</h3>
<p>Реализовать программу, в которой вводятся вещественные числа, выводятся в порядке возрастания модулей, а также вычисляется их среднее арифметическое. Использовать <code>PriorityQueue</code>.</p>
<h3>3.4 Буквы в обратном порядке</h3>
<p>Ввести слово и вывести его буквы в обратном порядке. Использовать стек.</p>
<h3>3.5 Проверка корректности скобок с учетом кавычек*</h3>
<p>Дополнить пример 2.6 проверкой, не находятся ли скобки в кавычках. В этом случае они должны игнорироваться.</p>
<h3>3.6 Данные о пользователях*</h3>
<p>Представить данные о пользователях в виде ассоциативного массива (имя / пароль) с предположением, что все имена пользователей разные. Вывести данные о пользователях с длиной пароля более 6 символов.</p>
<h3>3.7 Определение частоты вхождения букв*</h3>
<p>Ввести предложение и вывести все различные буквы, входящие в предложение и количество их вхождения. Использовать ассоциативный массив.</p>
<h3>3.8 Реализация двухсвязного списка*</h3>
<p>Реализовать обобщенный класс, представляющий двусвязный список</p>
<h3>3.9 Реализация функции удаления элемента из дерева*</h3>
<p>Добавить к примеру 2.9 функцию удаления заданного элемента из дерева.</p>
<h3>3.10 Реализация красно-черного дерева (задача повышенной трудности)</h3>
<p>Самостоятельно реализовать ассоциативный массив на базе красно-черного дерева.</p>
<h3>3.11 Создание собственного контейнера на базе массива*</h3>
<p>Создать обобщенный класс для представления одномерного массива, индекс элементов которого меняется от определенного значения <code>From</code> до значения <code>To</code> включительно. Эти значения могут быть как положительными, так и отрицательными. Класс должен реализовывать интерфейс <code>Collection</code>. Рекомендуется использовать класс <code>AbstractList</code> в качестве базового.</p>
<h3>3.12 &quot;Гибкий&quot; массив*</h3>
<p>Создать обобщенный класс для представления одномерного массива, который автоматически расширяется, когда пользователь обращается к несуществующему элементу. Например, если создан пустой массив a, первое обращение (для чтения или записи) к элементу по индексу обеспечит расширение массива так, чтобы он содержал n + 1 элемент с индексами от 0 до n-го включительно. Если определенные элементы уже существовали, они сохраняются и массив дополняется новыми элементами. Если элемент с индексом уже существует, осуществляется обычное обращение.</p>
<p>Создать метод получения количества элементов, методы доступа по индексу, метод предоставления итератора, а также перекрыть функцию <code>ToString()</code>. Осуществить тестирование всех возможностей класса.</p>
<h2>4 Контрольные вопросы</h2>
<ol>
  <li>Что такое коллекция?</li>
  <li>Почему в контейнерном классе нельзя хранить целые и действительные числа непосредственно, а можно только ссылки?</li>
  <li>Как из массива получить список?</li>
  <li>Как сохранить в списке целые и действительные значения?</li>
  <li>Когда целесообразнее использовать <code>ArrayList</code> по сравнению с <code>LinkedList</code>?</li>
  <li>Когда целесообразнее использовать <code>LinkedList</code> по сравнению с <code></code> <code>ArrayList</code>?</li>
  <li>В чем преимущество использования итераторов по сравнению с индексами элементов списка?</li>
  <li>Какие базовые интерфейсы описаны в пакете <code>java.util</code>?</li>
  <li>Какие контейнеры считаются устаревшими?</li>
  <li>Какая структура данных используется для реализации <code>LinkedList</code>?</li>
  <li>Чем множество отличается от списка?</li>
  <li>Как определить очередь в широком и узком смысле?</li>
  <li>Какие методы интерфейса <code>Queue</code> используются для добавления элементов?</li>
  <li>С какой целью методы работы с очередью продублированы в двух вариантах - с генерацией исключения и без?</li>
  <li>Для чего используется класс <code>PriorityQueue</code>?</li>
  <li>Можно ли с помощью <code>ArrayDeque</code> реализовать очередь?</li>
  <li>Для чего используются стеки?</li>
  <li>Какие есть стандартные способы реализации стека?</li>
  <li>Какие алгоритмы предоставляет класс <code>Collections</code>?</li>
  <li>Чем множество отличается от ассоциативного массива?</li>
  <li>Приведите примеры использования ассоциативных массивов.</li>
  <li>В чем отличия интерфейсов <code>Map</code> и <code>SortedMap</code>?</li>
  <li>Для чего используется класс <code>Properties</code>?</li>
  <li>Что такое хеширование?</li>
  <li>Как используются &quot;корзины&quot; для хранения данных в хеш-таблице?</li>
  <li>Что такое двоичное дерево?</li>
  <li>Что такое сбалансированное и несбалансированное дерево?</li>
  <li>Что такое красно-черное дерево и какие у него преимущества?</li>
  <li>Как создать собственный контейнер?</li>
  <li>Как реализовать контейнер только для чтения?</li>
</ol>
<p>&nbsp;</p>
    <div class="w3-clear nextprev">
        <a class="btn btn-info float-left" href="topic_2_01.html">Предыдущая</a>
        <a class="btn btn-info float-left" href="topic_2_03.html">Следующая</a>
    </div>
</div>
</div>

</div>
</div>
<a href="#top" id="up">up</a>
<footer class="container-fluid text-center">
    <p>&copy; 2003-2019 Л.В.Иванов</p>
</footer>
<script>
    $(document).ready(function () {
        // Add smooth scrolling to all links in navbar + footer link
        $("a[href='#top']").on('click', function (event) {

            // Make sure this.hash has a value before overriding default behavior
            if (this.hash !== "") {

                // Prevent default anchor click behavior
                event.preventDefault();

                // Store hash
                var hash = this.hash;

                // Using jQuery's animate() method to add smooth page scroll
                // The optional number (900) specifies the number of milliseconds it takes to scroll to the specified area
                $('html, body').animate({
                    scrollTop: $(hash).offset().top
                }, 900, function () {

                    // Add hash (#) to URL when done scrolling (default click behavior)
                    window.location.hash = hash;
                });
            } // End if
        });
        var offset = 200;
        var duration = 300;
        $('#up').fadeOut(0);
        $(window).scroll(function () {
            var winTop = $(window).scrollTop();
            if (winTop > offset) {
                $('#up').css("opacity", "0.8");
                $('#up').fadeIn(duration);
            } else {
                $('#up').fadeOut(duration);
            }
        });
    })
</script>

</body>
</html>
