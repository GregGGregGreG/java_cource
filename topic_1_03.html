<!DOCTYPE html>
<html lang="ru">
<head>
    <title>1.03 - Синтаксические конструкции языка Java</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <style>
        body {
            background: #dfdfdf;
        }

        /* Remove the navbar's default margin-bottom and rounded borders */
        .jumbotron {
            padding-top: 0;
            padding-bottom: 0;
        }

        #header {
            background-color: #445566;
        }

        #header h2, #header h4, #header h3, #header h5, #header p {
            margin-left: -10px;
            color: #ededed;
        }

        #header h2 {
            font-weight: bold;
        }

        #header h4 {
            font-size: 1.5em;
        }

        #content {
            background: white;
            padding-right: 9%;
            box-sizing: border-box;
        }

        p {
            text-align: justify;
        }

        img {
            max-width: 100%;
        }

        ul.nav, ul.side_menu {
            list-style-type: none;
            margin-left: -20px;
        }

        .navbar {
            margin-bottom: 0;
            border-radius: 0;
        }

        .navbar-inverse {
            background-color: #445566;
            border: none;
            border-top: 1px solid white;
        }

        .navbar-inverse .navbar-nav > .active > a, .navbar-inverse .navbar-nav > .active > a:hover, .navbar-inverse .navbar-nav > li > a:hover {
            background-color: #293b4c;
        }

        /* Set height of the grid so .sidenav can be 100% (adjust as needed) */
        .row.content {
            height: 450px
        }

        /* Set gray background color and 100% height */
        .sidenav {
            padding-top: 20px;
            height: 100%;
        }

        .btn-info {
            color: #fff;
            background-color: #445566;
            border: none;
            border-radius: 0;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .btn-info:hover {
            background-color: #293b4c;
        }

        .navbar-inverse .navbar-toggle:hover {
            background-color: #293b4c;
        }

        .hide {
            visibility: hidden;
        }

        .disa {
            cursor: default;
            opacity: 0.6;

        }

        .disa:hover {
            background-color: #445566;
        }

        /* Set black background color, white text and some padding */
        footer {
            background-color: #293b4c;
            color: white;
            padding: 15px;
        }

        #up {
            color: #fff;
            position: fixed;
            display: block;
            background: #293b4c;
            width: 40px;
            height: 40px;
            bottom: 64px;
            right: 30px;
            opacity: 0;
            border-radius: 50%;
            padding-left: 12px;
            padding-top: 8px;
            box-sizing: border-box;
        }

        /* On small screens, set height to 'auto' for sidenav and grid */
        @media screen and (max-width: 990px) {
            #content {
                padding-right: 10px;
            }

            #up {
                display: none !important;
            }
        }

        /* On small screens, set height to 'auto' for sidenav and grid */
        @media screen and (max-width: 767px) {
            .sidenav {
                height: auto;
                padding: 15px;
            }

            .row.content {
                height: auto;
            }
        }

        @media only screen and (max-width: 600px) {
            img.small_img {
                width: 40%;
                height: auto;
            }

            img.big_img {
                width: 90%;
                height: auto;
            }
        }

        .justified {
            text-align: justify;
            font-weight: normal
        }

        tt {
            color: #446699;
        }

        .style1 {
            font-family: "Times New Roman", Times, serif
        }
    </style>
</head>
<body id="top">
<div class="container-fluid text-left" id="header">
    <div class="container text-left col-md-3 col-sm-12">
        <img src="Images/icon-java.png" style="padding-top: 15px; box-sizing: border-box;">
    </div>
    <div class="container text-left col-md-9 col-sm-12">
        <h2>Язык программирования и технологии Java</h2>
        <h5>Разработчик курса Л. В. Иванов</h5>
        <h4>Модуль 1 Объектно-ориентированное программирование и язык Java</h4>

    </div>
</div>
<nav class="navbar navbar-inverse">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>
        <div class="collapse navbar-collapse" id="myNavbar">
            <!--div class="col-sm-12 col-md-3 sidenav">
            </div-->

            <ul class="nav navbar-nav">
                <li><a href="index.html">Главная</a></li>
                <li class="active"><a href="topic_1_01.html">Объектно-ориентированное программирование и язык Java</a>
                </li>
                <li><a href="topic_2_01.html">Платформа Java SE</a></li>
                <li><a href="">Разработка приложений JAVA EE</a></li>
            </ul>

        </div>
    </div>
</nav>

<div class="container-fluid text-left">
    <div class="row content">
        <div class="col-sm-12 col-md-3 sidenav">
            <ul class="side_menu">
                <li>1 Объектно-ориентированное программирование и язык Java
                  <ul class="side_menu">
                        <li><a href="topic_1_01.html">01 Парадигмы программирования. Основы объектно-ориентированного подхода</a></li>
                        <li><a href="topic_1_02.html">02 Язык программирования Java и Java-платформа</a></li>
                        <li>03 Синтаксические конструкции языка Java</li>
                        <li><a href="topic_1_04.html">04 Ссылочные типы. Массивы. Строки и классы-оболочки</a></li>
                        <li><a href="topic_1_05.html">05 Определение классов.  Наследование и полиморфизм</a></li>
                        <li><a href="topic_1_06.html">06 Вложенные типы. Интерфейсы. Лямбда-выражения и ссылки на методы</a></li>
                        <li><a href="topic_1_07.html">07 Перечисления. Исключения. Использование обобщений</a></li>
                        <li><a href="topic_1_08.html">08 Понятие паттернов проектирования. Порождающие паттерны</a></li>
                    </ul>
                </li>
                <li>2 Платформа Java SE
                  <ul class="side_menu">
                        <li><a href="topic_2_01.html">01 Платформа Java SE и ее составляющие</a></li>
                        <li><a href="topic_2_02.html">02 Работа с коллекциями в Java 7</a></li>
                        <li><a href="topic_2_03.html">03 Работа с текстовыми данными. Локализация</a></li>
                        <li><a href="topic_2_04.html">04 Работа с потоками ввода-вывода и файловой системой</a></li>
                        <li><a href="topic_2_05.html">05 Работа с XML. XML-сериализация</a></li>
                        <li>06 Тестирование и управление сборкой. Ведение системного журнала</li>
                        <li>07 Работа с потоками выполнения</li>
                        <li>08 Работа с контейнерами Java 8. Stream API</li>
                        <li>09 Поддержка сетевого взаимодействия</li>
                        <li>10 Работа с базами данных</li>
                        <li>11 Использование RTTI и рефлексии. Метапрограммирование. Аннотации</a></li>
                        <li>12 </a>Использование структурных паттернов</li>
                  </ul>
                </li>
                <li>3 Основы разработки приложений Java EE
                    <ul class="side_menu">
                        <li>01 Платформа Java EE. Web-приложения. Создание сервлетов</li>
                        <li>02 Основы создания страниц JSP</li>
                        <li>03 Работа с EJB. Создание Web-сервисов</li>
                        <li>04 Использование Spring Framework</li>
                        <li>05 Использование паттернов поведения и распределения ответственности </li>
                        <li>06 Дополнительные возможности Java 11</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div class="col-sm-12 col-md-9 text-left" id="content">
            <div class="w3-clear nextprev">
                <a class="btn btn-info float-left" href="topic_1_02.html">Предыдущая</a>
                <a class="btn btn-info float-left" href="topic_1_04.html">Следующая</a>
            </div>
            <h1>Синтаксические конструкции языка Java</h1>
            <h2>1 Теоретическая часть</h2>
        <h3>1.1 Элементы исходного текста</h3>
        <p>В Java различаются заглавные и строчные буквы.</p>
        <p>Исходный текст на Java состоит из лексем. <i>Лексема</i> (token) &#8211 это последовательность символов,
            имеющих определенное совокупное значение. Между отдельными лексемами располагают разделители &#8211 пробел,
            табуляция, новая строка и т. д.<i> </i>Лексемы делятся на следующие группы:</p>
        <ul>
            <li>ключевые слова</li>
            <li>идентификаторы</li>
            <li>литералы</li>
            <li>знаки операций.</li>
        </ul>
        <p>Набор ключевых слов ограничен. Ключевые слова нельзя использовать в качестве идентификаторов, т.е. они
            являются зарезервированными. В тексте занятий зарезервированные слова выделяются жирным шрифтом. Некоторые
            слова зарезервированы (<b><code>const</code></b> и <b><code>goto</code></b>), но не являются ключевыми. Эти
            слова нельзя использовать ни в каком контексте.</p>
        <p>Идентификаторы используются для именования переменных, функций и других программных объектов. Первым символом
            должна быть буква или символ &quot;_&quot; (underscore character). Далее могут использоваться также цифры.
            Использование символа подчеркивания в начале имени нежелательно.</p>
        <p>Хороший стиль программирования предполагает следующие правила именования:</p>
        <ul>
            <li>имя переменной или функции начинается со строчной буквы</li>
            <li>имя класса или интерфейса начинается с заглавной буквы</li>
            <li>имя пакета состоит из одних строчных букв</li>
        </ul>
        <p>Чем больше область видимости имени, тем это имя должно быть длиннее и содержательнее. Классы крайне
            нежелательно именовать одной буквой. Однобуквенные переменные обычно определяются внутри небольшого
            программного блока &#8211 короткой функции, цикла и т.д.</p>
        <p>Целесообразно использовать содержательные имена, отражающие природу объекта или функции. Нельзя использовать
            пробелы внутри идентификатора. Поэтому, если необходимо создать идентификатор из нескольких слов, эти слова
            пишут слитно, начиная второе, третье и другие слова с большой буквы. Например, можно создать такое имя
            переменной:</p>
        <blockquote>
            <pre class="justified">thisIsMyVariable</pre>
        </blockquote>
        <p>Для содержательных имен целесообразно использовать английскую мнемонику. Имена статических констант состоят
            из прописных букв и символа подчеркивания, например <code>PI</code>, <code>CONST_VALUE</code> и т.д.</p>
        <p><i>Комментарии</i> &#8211 это текст внутри исходного кода, который не обрабатывает компилятор. Комментарии
            могут содержать произвольный текст с использованием любых символов. Символы /* начинают комментарий, который
            завершается символами */. Такие комментарии не могут быть вложенными. Символы // начинают комментарий,
            который завершается концом текущей строки.</p>
        <p>Язык Java поддерживает также так называемые комментарии Javadoc (/**&nbsp; */).</p>
        <p>Специальное средство, входящее в JDK &#8211 программа <code>javadoc.exe</code> &#8211 использует комментарии
            третьего вида для автоматической генерации документации. Для этого такие комментарии должны быть
            отформатированы по стандартам Javadoc. Можно добавлять комментарии для уровня классов и интерфейсов, а также
            для уровня методов и полей. Комментарии Javadoc должны быть размещены перед соответствующими фрагментами
            кода. Каждый комментарий состоит из описания и тегов. В комментарии javadoc можно вставлять теги
            форматирования HTML. Не рекомендуется вставлять теги, обеспечивающие вывод жирным шрифтом, курсивом,
            смысловое выделение и т. д. Имеется специальный набор тегов Javadoc, таких как <code>@author</code>, <code>@param</code>,
            <code>@return</code> и т. д. Эти теги обеспечивают стандартное представление документации, касающейся
            классов и методов. Например, следующие комментарии перед методом</p>
        <blockquote>
      <pre>/**
* Возвращает имя файла по соответствующему индексу.&lt;br&gt;
* Имена файлов хранятся в массиве строк.
* @param i индекс
* @return имя файла.
* */
<b>public</b> String getFileName(<b>int</b> i) {
    <b>return</b> names[i];
}</pre>
        </blockquote>
        <p>обеспечивают генерацию следующего фрагмента HTML-файла документации:</p>
        <table border="1" cellpadding="3" cellspacing="0" width="100%">
            <tr bgcolor="#CCCCFF">
                <td colspan=1><font size="+2"> <b>Method Detail</b> </font></td>
            </tr>
        </table>
        <h3>getFileName</h3>
        <pre>
public String <b>getFileName</b>(int&nbsp;i)</pre>
        <dl>
            <dd>Возвращает имя файла по соответствующему индексу.<br>
                Имена файлов хранятся в массиве строк.
            </dd>
        </dl>
        <dl>
            <dt><b>Parameters:</b>
            <dd><code>i</code> - индекс</dd>
            <dt><b>Returns:</b>
            <dd>file имя файла.</dd>
        </dl>
        <hr>
        <h3>1.2 Определение локальных переменных. Примитивные типы</h3>
        <p>Переменная может быть <i>определена</i> (выделяется память для переменной) и <i>проинициализирована</i>
            (присвоено начальное значение). В некоторых языках программирования (например, в С++) переменные также могут
            быть <i>объявлены</i> (описаны без создания).</p>
        <p>Локальные переменные определяются внутри методов. Описание локальных переменных начинается с имени типа,
            после которого следует список имен переменных этого типа. Переменные могут быть проинициализированы
            начальными значениями. Например:</p>
        <blockquote>
      <pre><b>int</b> i = 11;
<b>double</b> d = 0, x;
<b>float</b> f; <b>
int</b> j, k;</pre>
        </blockquote>
        <p>Локальные переменные могут быть определены в любом месте внутри тела функции.</p>
        <p>В Java нельзя использовать значения неинициализированных переменных. Например, следующий фрагмент кода
            приведет к ошибке компиляции:</p>
        <blockquote>
      <pre><b>int</b> i;
<b>int</b> k = i + 1; // Ошибка! Неопределенное значение</pre>
        </blockquote>
        <p>Неинициализированные переменные можно использовать для присваивания им значений:</p>
        <blockquote>
      <pre><b>int</b> i;
<b>int</b> k = 10;
i = k + 12;</pre>
        </blockquote>
        <p>Ключевое слово <b><code>final</code></b> применительно к именам переменных означает, что переменные не могут
            быть изменены.</p>
        <blockquote>
            <pre><b>final int</b> h = 0;</pre>
        </blockquote>
        <p>Слово <b><code>const</code></b> зарезервировано, но не используется.</p>
        <p>Примитивные, или встроенные типы делятся на целые типы, типы с плавающей точкой, символьные и Булевы.
            Примитивные типы приведены в следующей таблице.</p>
        <p><strong>Примитивные типы данных</strong></p>
        <div>
            <table class="simple" border cellpadding=5 width="60%" cellspacing="0">
                <th width="19%">Ключевое слово</th>
                <th width="64%">Описание</th>
                <th width="17%">Размеры</th>
                <tr>
                    <td colspan=3 align=center>Целые типы</td>
                </tr>
                <tr>
                    <td width="19%"><b><code>byte</code></b></td>
                    <td width="64%"> маленькое целое (от -128 до 127)</td>
                    <td width="17%">8 битов</td>
                </tr>
                <tr>
                    <td width="19%"><b><code>short</code></b></td>
                    <td width="64%">короткое целое (от -32768 до 32767)</td>
                    <td width="17%">16 битов</td>
                </tr>
                <tr>
                    <td width="19%"><b><code>int</code></b></td>
                    <td width="64%">целое (-2147483648 до 2147483647)</td>
                    <td width="17%">32 бита</td>
                </tr>
                <tr>
                    <td width="19%"><b><code>long</code></b></td>
                    <td width="64%">длинное целое (от -9223372036854775808 до 9223372036854775807)</td>
                    <td width="17%">64 бита</td>
                </tr>
                <tr>
                    <td colspan=3 align=center>Типы с плавающей точкой</td>
                </tr>
                <tr>
                    <td width="19%"><b><code>float</code></b></td>
                    <td width="64%">вещественное число обычной точности</td>
                    <td width="17%">32 бита</td>
                </tr>
                <tr>
                    <td width="19%"><b><code>double</code></b></td>
                    <td width="64%">вещественное число повышенной точности</td>
                    <td width="17%">64 бита</td>
                </tr>
                <tr>
                    <td colspan=3 align=center>Прочие типы</td>
                </tr>
                <tr>
                    <td width="19%"><b><code>char</code></b></td>
                    <td width="64%">символ кодировки Unicode</td>
                    <td width="17%">16 битов</td>
                </tr>
                <tr>
                    <td width="19%"><b><code>boolean</code></b></td>
                    <td width="64%">Булево значение (<code><b>true</b></code> или <code><b>false</b></code>)</td>
                    <td width="17%">&nbsp;</td>
                </tr>
            </table>
        </div>
        <p>Во многих других языках (например, в С и в С++) формат и размеры примитивных типов данных зависят от
            платформы (DOS, Win 32 и т. д.). В Java размеры и формат стандартизированы и не зависят от платформы.</p>
        <p>Константы целого типа записываются в виде последовательности десятичных цифр. Тип константы по умолчанию
            &#8211 <code><b>int</b></code>. Он может быть уточнен добавлением в конце константы букв <code>L</code> или
            <code>l</code> (тип <b> <code>long</code></b>). Целые константы могут записываться в восьмеричной системе
            счисления, в этом случае первой цифрой должна быть цифра 0, число может содержать только цифры 0 ... 7.
            Целые константы можно записывать и в шестнадцатеричной системе счисления, в этом случае запись константы
            начинается с символов <code>0x</code> или <code>0X</code>. Для обозначения цифр более 9 используются
            латинские буквы <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code> и
            <code>f</code> (большие или маленькие). Например:</p>
        <blockquote>
      <pre><b>int</b> octal = 023; // 19
<b>int</b> hex = 0xEF;  // 239</pre>
        </blockquote>
        <p>В Java 7 появилась возможность задавать также двоичные константы (с использованием префиксов <code>0B</code>
            или <code>0b</code>):</p>
        <blockquote>
            <pre><b>int</b> m = 0b110011; // 51</pre>
        </blockquote>
        <p>Кроме того, группы разрядов в константах можно разделять знаком подчеркивания, например: <code><b>int</b> n =
            1_048_576;</code></p>
        <p>Константы типа <b><code>char</code></b> берут в одиночные кавычки (апострофы), значение константы задается
            либо знаком из текущего набора символов, или целой константой, которой предшествует обратная косая черта
            (символ с заданным кодом). Есть ряд специальных символов, которые могут использоваться как значение
            константы типа <b><code>char</code></b> (такие двойные символы называются управляющими последовательностями,
            или escape-последовательностями):</p>
        <blockquote>
      <pre>'\n' - новая строка,
'\t' - горизонтальная табуляция,
'\r' - перевод на начало строки, 
'\'' - одиночные кавычки (апостроф),
'\"' - двойные кавычки,
'\\' - обратная косая черта (backslash).</pre>
        </blockquote>
        <p>Для хранения данных символьного типа в памяти используется таблица Unicode.</p>
        <p>Константы вещественных типов могут записываться в форме с точкой или в экспоненциальном формате и по
            умолчанию имеют тип<b> <code>double</code></b>. При необходимости тип константы можно уточнить, записав
            конце суффикс <code>f</code> или <code>F</code> для типа <b><code>float</code></b>, суффикс <code>d</code>
            или <code>D</code> для типа <b><code>double</code></b>. Например:</p>
        <blockquote>
      <pre>1.5f    // 1.5   типа float
2.4E-2d // 0.024 типа double</pre>
        </blockquote>
        <p>Целые значения можно присваивать переменным вещественных типов, но не наоборот. Сужающее преобразование
            (вещественного к целому, числа с двойной точностью к числу с одинарной точностью) связано с риском потери
            данных и должно осуществляться явно, а не по умолчанию:</p>
        <blockquote>
      <pre><b>int</b>   i  = 10;
<b>float</b> f  = i;        // Такое преобразование допускается
<b>long</b>  l  = f;        // Ошибка! Сужающее преобразование
<b>long</b>  l1 = (<b>long</b>) f; // Явное приведение типов</pre>
        </blockquote>
        <p> Числа без десятичной точки интерпретируются как целые (типа <b><code>int</code></b>). Числа с плавающей
            точкой имеют тип <b><code>double</code></b>. Для приведения их к более узким типам используется явное
            приведение типов:</p>
        <blockquote>
      <pre><b>float</b> f  = 10.5;         // Ошибка! Сужающее преобразование
<b>float</b> f1 = (<b>float</b>) 10.5; // Явное приведение типов</pre>
        </blockquote>
        <p>За исключением редких случаев, связанных с критической нехваткой памяти, вместо <code><b>float</b></code>
            целесообразно использовать <code><b>double</b></code>. Тем более, что стандартные математические функции для
            работы с вещественными числами получают параметры и возвращают результат типа <b><code>double</code></b>.
        <p>В Java нет беззнаковых целых типов. Это связано с тем, что беззнаковые целые считаются небезопасными, так как
            не вполне корректно ведут себя при переходе через 0. Обычно такие ошибки не отслеживаются при выполнении.
            Например, при использовании беззнаковых целых в C++ мы можем получить такие странные результаты:</p>
        <blockquote>
      <pre>// C++:<b>
unsigned int</b> a = 1;
<b>unsigned int</b> b = 2;
<b>unsigned int</b> c = a - b; // c = 4294967295</pre>
        </blockquote>
        <p>Единственным оправданным применением беззнаковых целых могли бы быть побитовые операции (они будут
            рассмотрены ниже). Однако и в этом случае в Java используются целые со знаком.</p>
        <p>Булевым переменным можно присваивать только константы <code><b>true</b></code> и <code><b>false</b></code>.
            Переменные типа <b><code>boolean</code></b> нельзя неявно или явно приводить к другим типам и наоборот.
            Отсутствие неявного приведения целого к типу <b><code>boolean</code></b> позволяет избежать ошибок,
            связанных с неправильным использованием присваивания.</p>
        <p>Константа-строка состоит из символов, которые берут в двойные кавычки. Например:</p>
        <blockquote>
            <pre>&quot;Это строка&quot;</pre>
        </blockquote>
        <p>Результат сложения строки со значением другого типа обеспечивает преобразование значения в представление в
            виде строки. В частности, такой подход применяют для вывода значений нескольких переменных. Например:</p>
        <blockquote>
      <pre><b>int</b> k = 1;
<b>double</b> d = 2.5;
System.out.println(k + &quot; &quot; + d); // 1 2.5</pre>
        </blockquote>
        <h3>1.3 Выражения и операции</h3>
        <p>Внутри методов классов, из которых состоит программа, могут содержаться утверждения (инструкции, операторы),
            которые, в свою очередь, состоят из выражений. <i>Выражение</i> состоит из одной или нескольких операций.
            Объекты операций называются <i>операндами</i>. Операции бывают <i>унарными</i> (один операнд),
            <i>бинарными</i> (два операнда) и <i>тернарными</i> (три операнда).</p>
        <p>Хороший стиль программирования предполагает выделение знаков бинарных операций пробелами с двух сторон.</p>
        <p>К <i>арифметическим операциям</i> относятся <code>+</code>, &#8211 (бинарные и унарные), <code>*</code>,
            <code>/</code> а также операция взятия остатка <code>%</code> (применима только к целым). Если
            <code>/</code> применяется к целым (оба операнда &#8211 целые), то результатом деления будет тоже целое, а
            остаток отбрасывается. Если хотя бы один операнд имеет тип с плавающей точкой (вещественный), мы получаем
            вещественный результат.</p>
        <blockquote>
      <pre class="justified">System.out.println(1 / 2);   // 0
System.out.println(1.0 / 2); // 0.5</pre>
        </blockquote>
        <p><i>Побитовые операции</i> используются для операндов целочисленного типа.</p>
        <p>Унарная операция НЕ (<code>~</code>) применяется для инвертирования разрядов операнда.</p>
        <blockquote>
      <pre><b>byte</b> bits = 23;           // 0 0 0 1 0 1 1 1
bits = (<b>byte</b>)~bits;       // 1 1 1 0 1 0 0 0 или 232
System.out.println(bits); // -24</pre>
        </blockquote>
        <p>Последний результат кажется несколько странным. Дело в том, что для представления отрицательных чисел
            используется их двоичное дополнение до 2 в степени количества бит, в данном случае &#8211 до 256.</p>
        <p>
        <div align="center">232 &#8211 256 = -24</div>
        </p>
        <p>При побитовом отрицании и других подобных операциях необходимо явное приведение к типу
            <b><code>byte</code></b>, так как по умолчанию побитовые операции возвращают целое значение.</p>
        <p>Бинарные операции сдвига влево (<code><<</code>) и вправо (<code>>></code>) предназначены для сдвига разрядов
            первого операнда на число разрядов, определяемое вторым операндом. При этом разряды, которые выходят за
            границу, отбрасываются, а вместо недостающих вставляются нули.</p>
        <blockquote>
      <pre><b>byte</b> bits = 1;               // 0 0 0 0 0 0 0 1
bits = (<b>byte</b>) (bits &lt;&lt; 3);   // 0 0 0 0 1 0 0 0
System.out.println(bits);    // 8
bits = (<b>byte</b>) (bits &gt;&gt; 2);   // 0 0 0 0 0 0 1 0
System.out.println(bits);    // 2</pre>
        </blockquote>
        <p>При работе с целыми величинами операция <code>>></code> сохраняет знак величины. Специальная операция сдвига
            <code>>></code><code>> </code>(отсутствующая в С++) сдвигает все биты, в том числе и старший.</p>
        <blockquote>
      <pre><b>byte</b> bits = -24;          // 1 1 1 0 1 0 0 0
<b>int</b> i = bits &gt;&gt; 1;
System.out.println(i);    // -12
i = bits &gt;&gt;&gt; 1;
System.out.println(i);    // 2147483636</pre>
        </blockquote>
        <p>Бинарная операция И (<code>&</code>) выполняет логическую операцию И поразрядно для своих операндов.
            Аналогично, операция ИЛИ (<code>|</code>) поразрядно выполняет логическую операцию ИЛИ. Бинарная операция
            "исключающее ИЛИ" (<code>^</code>) выполняет операцию "исключающее ИЛИ" для каждого разряда: для одинаковых
            разрядов результат 0, а для отличающихся -1.</p>
        <blockquote>
      <pre>
<b>byte</b> result;
<b>byte</b> b1 = 101;              //  0 1 1 0 0 1 0 1
<b>byte</b> b2 = 47;               //  0 0 1 0 1 1 1 1
result = (<b>byte</b>) (b1 &amp; b2);  //  0 0 1 0 0 1 0 1
System.out.println(result); //  37     
result = (<b>byte</b>) (b1 | b2);  //  0 1 1 0 1 1 1 1
System.out.println(result); //  111
result = (<b>byte</b>) (b1 ^ b2);  //  0 1 0 0 1 0 1 0
System.out.println(result); //  74</pre>
        </blockquote>
        <p>К <i>операциям отношения</i> относятся проверка на равенство <code>==</code> и на неравенство <code>!=</code>
            , а также проверки > >= < <=.</p>
        <p>К <i>логическим операциям</i> относятся логическое И (<code>&&</code>) и ИЛИ (<code>||</code>). Операции
            отношения и логические возвращают значение типа <b><code>boolean</code></b> (<b><code>true</code></b> &#8211
            если условие истинно, и <b><code>false</code></b> &#8211 если условие ложно). Логическое отрицание !
            преобразует свой операнд в истину (<b><code>true</code></b>) если он равен <b><code>false</code></b> и в
            ложь (<b><code>false</code></b>) если он равен <b><code>true</code></b>.</p>
        <p>В качестве логических можно использовать побитовые операции И (<code>&</code>) и ИЛИ (<code>|</code>). При
            использовании этих операций, в отличие от логических операций И (<code>&&</code>) и ИЛИ (<code>||</code>),
            оба операнда (если это выражения) вычисляются полностью.</p>
        <p>К <i>операциям присваивания</i><b> </b>относятся операции простого и составного присваивания. Результатом
            операции простого присваивания является значение того выражения, которое присваивается левому операнду.</p>
        <p>Составное присваивание можно представить в общем виде следующим образом:</p>
        <blockquote>
            <pre>a op= b </pre>
        </blockquote>
        <p>В данном случае op &#8211 арифметическая или побитовая операция: <code>+ - * / % | & ^ << >></code>. Каждая
            составная операция эквивалентна следующему присваиванию:</p>
        <blockquote>
            <pre>a = (a) op (b);</pre>
        </blockquote>
        <p>Например,</p>
        <blockquote>
            <pre>x += 5;</pre>
        </blockquote>
        <p>эквивалентно</p>
        <blockquote>
            <pre>x = x + 5;</pre>
        </blockquote>
        <p><i>Операция инкремента</i> ++ обеспечивает увеличение целой переменной на единицу. Она имеет две формы:
            префиксную и постфиксную. Префиксная форма обеспечивает увеличение переменной до того, как значение операции
            будет использовано, а постфиксная &#8211 после. <i>Операция декремента</i> (--) обеспечивает уменьшение
            переменной на единицу и правила ее использования аналогичны.</p>
        <p><i>Условная операция</i> (тернарная) имеет следующий вид:</p>
        <blockquote>
            <pre>условие ? выражение1 : выражение2 </pre>
        </blockquote>
        <p>Вначале вычисляется значение условия. Если оно истинно, то вычисляется выражение1 и его значение возвращается
            условной операцией. Если значение условия ложно, то вычисляется выражение2 и возвращается его значение.</p>
        <p>Порядок применения унарных операций и операций присваивания "справа налево", а всех остальных операций &#8211
            "слева направо".</p>
        <p>В Java есть операция &quot;запятая&quot;, которая разрешается только в заголовках циклов, например:</p>
        <blockquote>
      <pre><b>int</b> i, j;
<b>for</b> (i = 0, j = 0; i &lt; 10; i++, j += 2) {
    System.out.println(i + &quot; &quot; + j);
}</pre>
        </blockquote>
        <p>В Java не допускается непосредственная работа с указателями, следовательно, нет операций разыменования,
            выбора элемента по указателю и взятия адреса (<code>*</code>, <code>-&gt;</code> и <code>&amp;</code>).</p>
        <p>В Java нет операции <b><code>sizeof</code></b>() поскольку ее главное предназначение в С++ &#8211 выяснять
            размеры тех или иных данных при переносе исходного текста на другую платформу. В Java размеры всех типов
            стандартизированы.</p>
        <p>Операции имеют приоритет, который можно изменить, используя скобки. Далее в таблице приведены операции Java в
            порядке убывания приоритета.</p>
        <div>
            <table class="simple" border cellpadding=5 width="60%" cellspacing="0">
                <tr>
                    <th id="h1" width="197" height="33">Операции</th>
                    <th id="h2" width="497" height="33">Обозначение</th>
                </tr>
                <tr>
                    <td headers="h1" width="197">постфиксные</td>
                    <td headers="h2" width="497"><code>++ --</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">унарные (префиксные)</td>
                    <td headers="h2" width="497"><code>++ -- + - ~ !</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">умножение и деление</td>
                    <td headers="h2" width="497"><code>* / %</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">сложение и вычитание</td>
                    <td headers="h2" width="497"><code>+ -</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">сдвиг</td>
                    <td headers="h2" width="497"><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">операции отношения</td>
                    <td headers="h2" width="497"><code>&lt; &gt; &lt;= &gt;= <b>instanceof</b></code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">операции проверки равенства</td>
                    <td headers="h2" width="497"><code>== !=</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">побитовое И</td>
                    <td headers="h2" width="497"><code>&amp;</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">побитовое исключающее ИЛИ</td>
                    <td headers="h2" width="497"><code>^</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">побитовое ИЛИ</td>
                    <td headers="h2" width="497"><code>|</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">логическое И</td>
                    <td headers="h2" width="497"><code>&amp;&amp;</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">логическое ИЛИ</td>
                    <td headers="h2" width="497"><code>||</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">тернарная операция</td>
                    <td headers="h2" width="497"><code>? :</code></td>
                </tr>
                <tr>
                    <td headers="h1" width="197">присваивание</td>
                    <td headers="h2" width="497"><code>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=
                        &gt;&gt;&gt;=</code></td>
                </tr>
            </table>
        </div>
        <h3> 1.4 Инструкции (операторы). Управление выполнением программы</h3>
        <p><i>Инструкция</i> (утверждение, оператор, англ. statement) &#8211 наименьшая автономная часть языка
            программирования, определяющие действия, выполняемые программой. Программа представляет собой
            последовательность инструкций. Большинство инструкций языка Java аналогично C++.</p>
        <p><i>Пустая инструкция</i> состоит из одной точки с запятой. Она используется в тех случаях, когда по
            синтаксису необходимо какое-либо утверждение, а реально действия не требуются.</p>
        <p><i>Инструкция-выражение</i> представляет собой полное выражение, заканчивающееся точкой с запятой. Например:
        </p>
        <blockquote>
            <pre>k = i + j + 1;</pre>
        </blockquote>
        <p><i>Составная инструкция</i> <b>- </b>это последовательность инструкций, заключенная в фигурные скобки.
            Составную инструкцию часто именуют блоком. После закрывающей фигурной скобки в конце блока точка с запятой
            не ставится. Синтаксически блок может рассматриваться как отдельная инструкция, однако он также играет роль
            в определении видимости и времени жизни идентификаторов. Идентификатор, объявленный внутри блока, имеет
            область видимости от точки определения до закрывающейся фигурной скобки. Блоки могут неограниченно
            вкладываться друг в друга.</p>
        <p>В Java нельзя во внутреннем блоке определять локальные имена, уже описанные в наружном блоке:</p>
        <blockquote>
      <pre>{
    <b>int</b> i = 0; {
        <b>int</b> j = 1; // Переменная j определяется во внутреннем блоке
        <b>int</b> i = 2; // Ошибка! Переменная i определена в наружном блоке
    }
}</pre>
        </blockquote>
        <p><i>Инструкции выбора</i> &#8211 условная инструкция и переключатель. Условная инструкция применяется в двух
            видах:</p>
        <blockquote>
      <pre><b>if</b> (условное_выражение)
    инструкция_1
<b>else</b>
    инструкция_2
</pre>
        </blockquote>
        <p>или</p>
        <blockquote>
      <pre><b>if</b> (условное_выражение)
    инструкция_1
</pre>
        </blockquote>
        <p> При выполнении данной инструкции вычисляется условное выражение и если оно истинно (<b><code>true</code></b>),
            то выполняется <code>инструкция_1</code>, а иначе &#8211 <code>инструкция_2</code>. Условное выражение
            должно быть типа <b><code>boolean</code></b>.</p>
        <p>Переключатель позволяет выбрать одну из нескольких возможных ветвей вычислений и строится по схеме:</p>
        <blockquote>
            <pre><b>switch</b> (целое_или_строковое_выражение) блок</pre>
        </blockquote>
        <p>Блок в этом случае представляет собой тело переключателя и имеет такой вид:</p>
        <blockquote>
      <pre>{
<b>case</b> константа_1: 
    инструкции
<b>case</b> константа_2: 
    инструкции
    ...
<b>default</b>: 
    инструкции
}</pre>
        </blockquote>
        <p>Выполнение переключателя состоит в вычислении управляющего выражения и переходе к группе инструкций,
            помеченных <b><code>case</code></b>-меткой, равной управляющему выражению, если такой метки нет, выполняются
            инструкции после метки <b><code>default</code></b> (которая может отсутствовать). При выполнении
            переключателя происходит переход на инструкцию с выбранной меткой и дальше инструкции выполняются в
            естественном порядке. Для того, чтобы не выполнять оставшихся инструкций в теле переключателя, необходимо
            использовать конструкцию <b><code>break</code></b>.</p>
        <p><i>Инструкции цикла</i> представлены в трех вариантах: цикл с предусловием, цикл с постусловием и цикл с
            параметром.</p>
        <p>Цикл с предусловием строится по схеме</p>
        <blockquote>
      <pre><b>while</b> (выражение-условие)
    инструкция (тело цикла)</pre>
        </blockquote>
        <p>При каждом повторении цикла вычисляется выражение-условие и если значение этого выражения
            <b><code>true</code></b>, выполняется инструкция &#8211 тело цикла. Если условие дает значение <b><code>false</code></b>,
            инструкция (тело цикла) не выполняется и осуществляется переход к последующим инструкциям.</p>
        <p>Цикл с постусловием строится по схеме:</p>
        <blockquote>
      <pre><b>do</b> 
    инструкция (тело цикла)
<b>while</b> (выражение-условие); </pre>
        </blockquote>
        <p>Выражение-условие вычисляется и проверяется после каждого повторения инструкции &#8211 тела цикла, цикл
            повторяется, пока условие выполняется. Тело цикла в цикле с постусловием выполняется хотя бы один раз.</p>
        <p>Цикл с параметром строится по схеме:</p>
        <blockquote>
      <pre><b>for</b> (E1; E2; E3)
    инструкция (тело цикла)
</pre>
        </blockquote>
        <p>где <code>E1</code>, <code>E2</code> и <code>E3</code> &#8211 выражения скалярного типа. Цикл с параметром
            реализуется по следующему алгоритму:</p>
        <ul>
            <li>вычисляется выражение <code>E1</code> (обычно это выражение выполняет подготовку к началу цикла);</li>
            <li>вычисляется выражение <code>E2</code> и если оно равно <b><code>false</code></b> выполняется переход к
                следующей инструкции программы (выход из цикла);
            </li>
            <li>если <code>E2</code> не равно <b><code>false</code></b>, выполняется инструкция &#8211 тело цикла;</li>
            <li>вычисляется выражение <code>E3</code> &#8211 выполняется подготовка к повторению цикла, после чего снова
                выполняется выражение <code>E2</code>.
            </li>
        </ul>
        <p>В следующем примере сумма</p>
        <blockquote>
            <pre>y = 1<font
                    face="Courier New, Courier, mono"><sup>2</sup> + 2<sup>2</sup> + 3<sup>2</sup> + ... + n<sup>2</sup></font></pre>
        </blockquote>
        <p>находится с помощью трех различных циклических конструкций.</p>
        <p>С помощью цикла <b><code>while</code></b>:</p>
        <blockquote>
      <pre><b>int</b> y = 0;
<b>int</b> i = 1;
<b>while</b> (i &lt;= n) {
    y += i * i;
    i++;
}</pre>
        </blockquote>
        <p>С помощью цикла <b><code>do ... while</code></b>:</p>
        <blockquote>
      <pre><b>int</b> y = 0;
<b>int</b> i = 1;
<b>do</b> {
    y += i * i;
    i++;
}
<b>while</b> (i &lt;= n);</pre>
        </blockquote>
        <p>С помощью цикла <b><code>for</code></b>:</p>
        <blockquote>
      <pre><b>int</b> y = 0;
<b>for</b> (<b>int</b> i = 1; i &lt;= n; i++) {
    y += i * i;
}</pre>
        </blockquote>
        <p>Начиная с версии JDK 1.5 (Java 5) синтаксис цикла <code><b>for</b></code> расширен для более удобной работы с
            массивами. Это расширение будет рассмотрено позже.</p>
        <p>В сочетании с инструкциями цикла используются <i>инструкции перехода</i> &#8211 инструкция
            <b><code>break</code></b>, позволяющая прервать выполнение самой внутренней из объемлющих циклических
            конструкций, инструкция <b><code>continue</code></b>, прерывающая текущую итерацию самого внутреннего из
            объемлющих его циклов <b><code>while</code></b>, <b><code>do</code></b> или <b><code>for</code></b>. Обычно
            <b><code>break</code></b> используется в конструкции:</p>
        <blockquote>
      <pre><b>if</b> (условие_досрочного_завершения_цикла)
    <b>break</b>;</pre>
        </blockquote>
        <p>В Java после ключевых слов <b><code>break</code></b> и <b><code>continue</code></b> можно разместить метку,
            которая предшествует одному из вложенных циклов. В этом случае утверждения относятся не к самому
            внутреннему, а к помеченному циклу. Например:</p>
        <blockquote>
      <pre><b>    int</b> a;
    . . .
<b>    double</b> b = 0;
label:
<b>    for</b> (<b>int</b> i = 0; i &lt; 10; i++) {
        <b>for</b> (<b>int</b> j = 0; j &lt; 10; j++) {
            <b>if</b> (i + j + a == 0) {
                <b>break</b> label;
            }
            b += 1 / (i + j + a);
        }
    }</pre>
        </blockquote>
        <p>Утверждение <b><code>goto</code></b> не допускается в языке Java, но <b><code>goto</code></b> является
            зарезервированным словом. Это слово никак не может быть использовано.</p>
        <h3>1.5 Использование стандартных средств ввода-вывода</h3>
        <p>Для обеспечения консольного ввода Java предоставляет несколько вариантов:</p>
        <ul>
            <li>непосредственное использование потока ввода <code>System.in</code>, в частности его функции
                <code>read()</code>;
            </li>
            <li>использование класса <span class="justified"><code>java.io.Console</code></span>;</li>
            <li>использование класса <code>java.util.Scanner</code>.</li>
        </ul>
        <p>Недостатком непосредственного использования функции <code>System.in.read()</code> является обилие ручной
            работы. Так, чтение данных с помощью потока <code>System.in</code> осуществляется в массив элементов типа
            <code>byte</code>. Далее, требуется определение реального количества введенных байтов. Кроме того,
            необходима обработка возможных исключений. С появлением классов <code>java.io.Console</code> и <code>java.util.Scanner</code>
            ввод данных с клавиатуры существенно упростился.</p>
        <p>Класс <code>java.io.Console</code>, появившийся в JDK 1.6, предоставляет упрощенные средства консольного
            ввода-вывода. Например, так с клавиатуры можно прочитать строку:</p>
        <blockquote>
      <pre>java.io.Console console = System.console(); // Получение системной консоли
String s = console.readLine();              // Чтение строки</pre>
        </blockquote>
        <p>К недостаткам использования данного класса можно отнести следующие:</p>
        <ul>
            <li>класс предоставляет простые функции только для чтения строки и вывода в стиле языка C, что связано с
                необходимостью дополнительной &quot;ручной&quot; работы;
            </li>
            <li>консольное окно большинства интегрированных сред не поддерживает консольного ввода, осуществляемого
                средствами класса <code>java.io.Console</code>, следовательно, отладка таких программ затруднена.
            </li>
        </ul>
        <p>Наиболее удобным средством ввода данных является класс <code>java.util.Scanner</code>. Класс
            <code>Scanner</code> предоставляет функции для чтения данных из различных источников, например, из файлов. В
            нашем случае мы указываем на необходимость чтения с клавиатуры (стандартный поток ввода
            <code>System.in</code>). Для чтения данных используются функции <code>nextDouble()</code> (чтение
            вещественного числа, которое может быть как целым, так и дробным), <code>nextInt()</code> (чтение заведомо
            целого числа) и т. д.</p>
        <p>Для возможности работы с классом <code>Scanner</code> перед описанием класса необходимо добавить:</p>
        <blockquote>
            <pre><b>import</b> java.util.Scanner;</pre>
        </blockquote>
        <p>Это позволит использовать имя <code>Scanner</code> без дополнительного префикса.</p>
        <p>Для организации чтения данных с помощью класса <code>Scanner</code> необходимо создать объект этого класса,
            проинициализировав его стандартным потоком <code>System.in</code>. Далее можно читать данные. Например:</p>
        <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> ScannerTest {

    <b>public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        String s = scanner.next();       // чтение строки
        <b>double</b> d = scanner.nextDouble(); // чтение вещественного числа
        <b>int</b> i = scanner.nextInt();       // чтение целого числа
        // ... использование введенных данных
    }

}</pre>
        </blockquote>
        <p>Большим удобством класса является возможность произвольного размещения данных во входном потоке: отдельные
            данные можно разделять пробелами, табуляцией, либо переводом строки. Единственное исключение &#8211
            использование функции <code>nextLine()</code>, которая читает данные до перевода строки.</p>
        <p>Для вывода в консольное окно используются функции <code>print()</code>, <code>println()</code> и <code>printf()</code>
            потока <code>out</code> класса <code>System</code>. Функции <code>print()</code> и <code>println()</code>
            реализованы для всех стандартных типов данных, но чаще всего их используют с параметрами строкового типа.
            Данные выводятся &quot;как есть&quot;, с использованием форматирования по умолчанию. В отличие от <code>print()</code>,
            <code>println()</code> функция осуществляет перевод курсора на новую строку после вывода.</p>
        <p>Функция <code>printf()</code> во многом аналогична подобной функции языка C. Первый параметр &#8211 так
            называемая строка форматирования. Далее следует произвольное количество параметров, значения которых следует
            вывести на консоль. Например:</p>
        <pre>    <b>double</b> d = 3.5;
    <b>int</b> i = 12;
    System.out.printf(&quot;%f %d%n&quot;, d, i);</pre>
        <p>При форматировании используются следующие спецификаторы формата:
          <div>
                <table class="simple" width="60%" border="1" cellspacing="0" cellpadding="3">
                    <tr>
                        <td>
                            <div align="center"><strong>Спецификатор формата</strong></div>
                        </td>
                        <td>
                            <div align="center"><strong>Выполняемое форматирование</strong></div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div align="center">%a</div>
                        </td>
                        <td>
        <p>Шестнадцатеричное значение с плавающей точкой</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%b</div>
            </td>
            <td>
                <p>Логическое (булево) значение аргумента</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%c</div>
            </td>
            <td>
                <p>Символьное представление аргумента</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%d</div>
            </td>
            <td>
                <p>Десятичное целое значение аргумента</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%h</div>
            </td>
            <td>
                <p>Хэш-код аргумента</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%e</div>
            </td>
            <td>
                <p>Экспоненциальное представление аргумента</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%f</div>
            </td>
            <td>
                <p>Десятичное значение с плавающей точкой</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%g</div>
            </td>
            <td>
                <p>Выбирает более короткое представление из двух: %е или %f</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%o</div>
            </td>
            <td>
                <p>Восьмеричное целое значение аргумента</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%n</div>
            </td>
            <td>
                <p>Вставка символа новой строки</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%t</div>
            </td>
            <td>
                <p>Время и дата</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%x</div>
            </td>
            <td>
                <p>Шестнадцатеричное целое значение аргумента</p></td>
        </tr>
        <tr>
            <td>
                <div align="center">%%</div>
            </td>
            <td>
                <p>Вставка знака %</p></td>
        </tr>
        </table>
    </div>
    <p>&nbsp;</p>
    <p>Более подробно форматированный вывод будет рассмотрен в следующем модуле при изучении работы с текстовыми
        данными.
    <p>Имеется также возможность вывода сообщений в поток <code>System.err</code> (стандартный поток сообщений об
        ошибках). Вывод в этот поток имеет более высокий приоритет, чем вывод в <code>System.out</code>, поэтому иногда
        сообщения об ошибках опережают &quot;нормальный&quot; вывод.</p>
    <h3>1.6 Использование аргументов командной строки</h3>
    <p>В Java можно организовать чтение аргументов из командной строки (отдельные слова, набранные в командной строке
        после имени главного класса). Например, следующая программа выводит первый аргумент командной строки на
        экран:</p>
    <blockquote>
      <pre><b>public static void</b> main(String[] args) {
    System.out.println(args[0]);
}</pre>
    </blockquote>
    <p>Аргументы командной строки в программе представлены в виде массива строк. Количество аргументов, которые были
        введены в командной строке, можно получить с помощью выражения <code>args.length</code>. В следующем примере
        программа осуществляет чтение из командной строки имени пользователя и выводит приветствие:</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>public class</b> HelloUser {

    <b>public static void</b> main(String[] args) {
        <b>if</b> (args.length &gt; 0) {
            System.out.println(&quot;Привет, &quot; + args[0] + &quot;!&quot;);
        }
        <b>else</b> {
            System.out.println(&quot;Привет, незнакомец!&quot;);
        }
    }

}</pre>
    </blockquote>
    <p>Из приведенного примера видно, что строки можно сшивать с помощью операции &quot;<code>+</code>&quot;.</p>
    <p>Допустим, необходимые пакеты были созданы в папке <code>c:\Examples</code>. Тогда после компиляции файла <code>HelloUser.java</code>
        запустить приложение можно такой командой:</p>
    <blockquote>
        <pre>java -cp c:\Examples ua.inf.iwanoff.third.HelloUser Вася</pre>
    </blockquote>
    <p>Получим сообщение на консоли:</p>
    <blockquote>
        <pre>Привет, Вася!</pre>
    </blockquote>
    <h3>1.7 Статические поля и методы</h3>
    <h4>1.7.1 Определение статических методов и полей</h4>
    <p>В Java термины "метод" и "функция" являются синонимами. Все инструкции могут располагаться только внутри
        функций.</p>
    <p>В языках программирования <i>функция</i> (function, процедура, подпрограмма) представляет собой часть
        программного кода, на которую передается управление при вызове, далее выполняются инструкции, определяющие код
        этой функции, после чего управление передается обратно в точку вызова функции. Функции могут быть переданы
        некоторые значения в виде так называемых <i>параметров</i> (или аргументов, arguments). На основании значений
        этих параметров вычисляется так называемое <i>возвращаемое значение</i>. Оно передается в точку вызова функции,
        где может быть использовано в различных целях, в соответствии со своим типом.</p>
    <p>При вызове функций все их локальные переменные, адреса функций, а также значения параметров и другие локальные
        данные размещаются в специальной области памяти, именуемой <em>программным стеком</em>, или <em>стеком
            вызовов</em> (call stack). При возвращении из функции область, занятая ее локальными данными, освобождается.
    </p>
    <p>Многие языки программирования позволяют создавать так называемые глобальные функции, вызов которых может быть
        напрямую осуществлен из любой точки программы. В Java нет глобальных функций. Аналогом глобальной функции
        является статический метод. Описание статической функции в простейшем случае имеет следующую структуру:</p>
    <blockquote>
        <pre>спецификаторы <b>static</b> тип_результата имя_функции(список_формальных_параметров) тело</pre>
    </blockquote>
    <p>Перед телом функции может располагаться список исключений, генерируемых внутри функции. Тело функции представляет
        собой составное утверждение (блок).</p>
    <p>В каждой Java-программе присутствует, по крайней мере, статическая функция <code>main()</code>, с которой
        начинается выполнение программы. Из метода <code>main()</code> могут быть вызваны другие функции. Функции могут
        вызываться из выражений (если эти функции возвращают результат) или отдельной инструкцией (если тип результата -
        <b><code>void</code></b>). Например:</p>
    <blockquote>
      <pre><b>static void</b> printHello() {
    System.out.println(&quot;Hello!&quot;);
}

<b>public static void</b> main(String[] args) {
    printHello();
}    </pre>
    </blockquote>
    <p>В Java не имеет значение расположение методов внутри класса. Нужный метод будет найден независимо от того, где он
        находится - выше или ниже по тексту.</p>
    <p><i>Статические поля</i> (static fields) в Java - это данные, описанные в области видимости класса и не являющиеся
        частью объекта. Статические поля во многом аналогичны глобальным переменным, используемым во многих языках
        программирования. Как и глобальные переменные, статические поля доступны для чтения и записи в различных
        функциях. Например:</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>public class</b> TestStatic {

    <b>static boolean</b> printed;

    <b>static void</b> printHello() {
        System.out.println(&quot;Hello!&quot;);
        printed = <b>true</b>;
    }

    <b>public static void</b> main(String[] args) {
        printed = <b>false</b>;
        printHello();
        System.out.println(printed); // true
    }

}</pre>
    </blockquote>
    <p>Статическое поле может быть проинициализировано начальным значением:</p>
    <blockquote>
        <pre><b>static boolean</b> printed = <b>false</b>;</pre>
    </blockquote>
    <p>В отличие от глобальных переменных, статические поля находятся в области видимости классов, что снижает
        вероятность конфликта имен. Кроме того, статические поля можно сделать закрытыми (<b><code>private</code></b>)
        и, следовательно, недоступными для функций других классов, а также защищенными (<b><code>protected</code></b>)
        от доступа из других иерархий классов и других пакетов.</p>
    <h4>1.7.2 Параметры функции</h4>
    <p>Параметры (аргументы) функции, указываемые в списке при определении функции, называются <i>формальными</i>
        (formal arguments). Параметры, указываемые при вызове функции, называются <i>фактическими</i> (actual
        arguments).</p>
    <p>При вызове функции выделяется память под ее формальные параметры, затем каждому формальному параметру
        присваивается значение фактического параметра. Проверяется соответствие типов формальных и фактических
        параметров и при необходимости выполняются стандартные преобразования типов.</p>
    <p>Список описаний формальных параметров:</p>
    <blockquote>
        <pre>тип_параметра имя_параметра, тип_параметра имя_параметра, ...</pre>
    </blockquote>
    <p>Пример определения функции, вычисляющей сумму двух целых чисел:</p>
    <blockquote>
      <pre><b>static int</b> sum(<b>int</b> a, <b>int</b> b) {
    <b>int</b> c = a + b;
    <b>return</b> c;   // Можно обойтись без переменной с: return a + b;
}</pre>
    </blockquote>
    <p>Вызов функции может быть осуществлен в выражении, в котором допустимо использование значения типа возвращаемого
        результата. При вызове функции указывается ее имя и список фактических параметров без указания их типов:</p>
    <blockquote>
      <pre><b>int</b> x = 4;
<b>int</b> y = 5;
<b>int</b> z = sum(x, y);
<b>int</b> t = sum(1, 3);</pre>
    </blockquote>
    <p>Функция может не иметь параметров:</p>
    <blockquote>
      <pre><b>static int</b> zero() {
    <b>return</b> 0;
}</pre>
    </blockquote>
    <p>При вызове такой функции также нужно использовать скобки:</p>
    <blockquote>
        <pre>System.out.println(zero());</pre>
    </blockquote>
    <p>Инструкция <b><code>return</code></b> обеспечивает механизм завершения работы функции. Если утверждение <b><code>return</code></b>
        сопровождается некоторым выражением, значение этого выражения становится возвращаемым значением функции.</p>
    <p>Функция может не возвращать никакого результата. Для обозначения этого используется тип <b><code>void</code></b>.
        В этом случае в теле функции <b><code>return</code></b> может отсутствовать. Например:</p>
    <blockquote>
      <pre><b>static void</b> hello() {
    System.out.println("Hello!");
}</pre>
    </blockquote>
    <p>Такую функцию можно вызвать только отдельным утверждением:</p>
    <blockquote>
        <pre>hello();</pre>
    </blockquote>
    <p>В Java отсутствие утверждения <b><code>return</code></b> допустимо только в функциях с типом результата <b><code>void</code></b>.
        В функциях с результатом типа <b><code>void</code></b> утверждение <b><code>return</code></b> позволяет досрочно
        остановить выполнение функции. Если в такой функции инструкция <b><code>return</code></b> присутствует, то после
        нее не должно быть никакого выражения.</p>
    <p>В Java параметры передаются по значению, т.е. значения фактических параметров копируются в память, отведенную для
        формальных параметров. При этом значения, с которыми работает функция - это ее собственные локальные копии
        фактических параметров и их изменение на эти параметры не влияет. При окончании функции эти локальные значения
        теряются. Таким образом, при передаче по значению содержимое фактических параметров не изменяется:</p>
    <blockquote>
      <pre><b>public class</b> Test;

    <b>static void</b> f(int k) {
        k++;       // k = 2;
    }

    <b>public static void </b>main(String[] args) {
        <b>int</b> k = 1;
        f(k);
        System.out.println(k); // k = 1;
    }
}</pre>
    </blockquote>
    <p>При передаче в функции параметров-ссылок ссылка копируется, а объект, на которую она ссылается - тот же самый что
        и в вызывающей функции. Действия, произведенные в функции над этим объектом, проводят к изменению его в
        вызывающей функции. В отличие от C++ и C#, Java не предоставляет возможности передачи параметров типов-значений
        по ссылке.</p>
    <h4>1.7.3 Перегрузка имен функций</h4>
    <p><i>Перегрузкой имени</i> (function name overload) называется его использование для обозначения разных операций
        над разными типами.</p>
    <p>Определения функций с одинаковыми именами могут встречаться несколько раз внутри одного класса. Если внутри
        одного класса встречается несколько функций с одинаковыми именами и списками формальных параметров, но типы
        возвращаемых значений различны, то компилятор выдает ошибку. Если списки формальных параметров двух функций
        различаются числом параметров или их типами, то эти две функции считаются перегрузкой одной функции.</p>
    <p>Перегруженные функции используются в тех случаях, если несколько функций выполняет одно и то же действие над
        объектами разных типов и удобно дать одинаковые имена всем этим функциям:</p>
    <blockquote>
      <pre>// Выбор максимального из двух целых чисел:
<b>static int</b> max(<b>int</b> x, <b>int</b> y) { }
// Выбор максимального из трех вещественных чисел:
<b>static double</b> max(<b>double</b> x, <b>double</b> y, <b>double</b> z) { }
// Выбор максимального элемента массива:
<b>static int</b> max(<b>int</b>[] a) { }</pre>
    </blockquote>
    <p>Для того чтобы определить, какую именно функцию следует вызывать, сравниваются количество и типы фактических
        параметров, указанные в вызове, с количеством и типами формальных параметров всех описаний функций с данным
        именем. В результате вызывается та функция, у которой формальные параметры наилучшим образом сопоставились с
        параметрами вызова, или выдается ошибка, если такой функции не нашлось.</p>
    <p><i>Примечание:</i> В отличие от C++ и C#, в Java не поддерживается механизм параметров по умолчанию.</p>
    <h4>1.7.4 Рекурсия</h4>
    <p>Функция может вызывать саму себя. Такой прием называется <em>рекурсией</em> (recursion). Рекурсия может быть
        прямой и косвенной. При использовании прямой рекурсии вызов функции находится в ней самой. Косвенная рекурсия
        осуществляется через другую функцию. Иногда рекурсию можно использовать вместо циклов. В следующем примере
        вычисляется сумма квадратов натуральных чисел:</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>public class</b> Sum {

    <b>public static double</b> sum(<b>int</b> n) {
        <b>if</b> (n &lt;= 1) {
            <b>return</b> 1;
        }
        <b>else</b> {
            <b>return</b> n * n + sum(n - 1);
        }
    }

  <b>  public static void</b> main(String[] args) {
        System.out.println(sum(5));
    }

}</pre>
    </blockquote>
    <p>Некоторые задачи решаются с помощью рекурсии более элегантно. Такие задачи, как обход дерева, работа с файловой
        системой, вычисление определителей через понижение порядка, решение задачи "Ханойские башни" и т.д. решить без
        рекурсии весьма сложно.</p>
    <p>Однако с точки зрения эффективности использование рекурсии дает всегда менее эффективное решение, чем
        использование циклов. Кроме того, неправильное использование рекурсии может привести к переполнению программного
        стека.</p>
    <h3>1.8 Вызов статических функций из других классов. Стандартные математические функции</h3>
    <p>Статические функции в пределах класса вызываются с использованием только имени функции и списка фактических
        параметров. Для того чтобы вызвать статическую функцию другого класса, необходимо указывать его имя и далее
        через точку имя функции. Таким способом можно обращаться к именам в пределах пакета, а также к классам и
        функциям пакета <code>java.lang</code>. Этот пакет содержит классы с очень полезными функциями. Например, класс
        <code>Math</code> предоставляет большое количество математических функций.</p>
    <table class="simple" width="60%" border="1" cellspacing="0" cellpadding="6">
        <tbody>
        <tr>
            <td width="28%">
                <div align="center"><b>Функция</b></div>
            </td>
            <td width="50%">
                <div align="center"><b>Содержание</b></div>
            </td>
            <td width="22%">
                <div align="center"><b>Пример вызова</b></div>
            </td>
        </tr>
        <tr>
            <td width="28%" height="15">
                <div align="left"><code><b>double</b> pow(<b>double</b> a, <b>double</b> b)</code></div>
            </td>
            <td width="50%" height="15">
                <div align="left">Вычисление <i>a<sup>b</sup></i></div>
            </td>
            <td width="22%" height="15">
                <div align="left"><code>Math</code>.<code>pow(x, y)</code></div>
            </td>
        </tr>
        <tr>
            <td width="28%">
                <div align="left"><code><b>double</b> sqrt(<b>double</b> a)</code></div>
            </td>
            <td width="50%">
                <div align="left">Вычисление квадратного корня</div>
            </td>
            <td width="22%">
                <div align="left"><code>Math</code>.<code>sqrt(x)</code></div>
            </td>
        </tr>
        <tr>
            <td width="28%">
                <div align="left"><code><b>double</b> sin(<b>double</b> a)</code></div>
            </td>
            <td width="50%">
                <div align="left">Вычисление синуса</div>
            </td>
            <td width="22%">
                <div align="left"><code>Math</code>.<code>sin(x)</code></div>
            </td>
        </tr>
        <tr>
            <td width="28%">
                <div align="left"><code><b>double</b> cos(<b>double</b> a)</code></div>
            </td>
            <td width="50%">
                <div align="left">Вычисление косинуса</div>
            </td>
            <td width="22%">
                <div align="left"><code>Math</code>.<code>cos(x)</code></div>
            </td>
        </tr>
        <tr>
            <td width="28%"><code><b>double</b> tan(<b>double</b> a)</code></td>
            <td width="50%">
                <div align="left">Вычисление тангенса</div>
            </td>
            <td width="22%">
                <div align="left"><code>Math</code>.<code>tan(x)</code></div>
            </td>
        </tr>
        <tr>
            <td width="28%"><code><b>double</b> asin(<b>double</b> a)</code></td>
            <td width="50%">
                <div align="left">Вычисление арксинуса</div>
            </td>
            <td width="22%">
                <div align="left"><code>Math</code>.<code>asin(x)</code></div>
            </td>
        </tr>
        <tr>
            <td width="28%"><code><b>double</b> acos(<b>double</b> a)</code></td>
            <td width="50%">
                <div align="left">Вычисление арккосинуса</div>
            </td>
            <td width="22%">
                <div align="left"><code>Math</code>.<code>acos(x)</code></div>
            </td>
        </tr>
        <tr>
            <td width="28%"><code><b>double</b> atan(<b>double</b> a)</code></td>
            <td width="50%">
                <div align="left">Вычисление арктангенса</div>
            </td>
            <td width="22%">
                <div align="left"><code>Math</code>.<code>atan(x)</code></div>
            </td>
        </tr>
        <tr>
            <td width="28%">
                <div align="left"><code><b>double</b> exp(<b>double</b> a)</code></div>
            </td>
            <td width="50%">
                <div align="left">Вычисление <i>e<sup>x</sup></i></div>
            </td>
            <td width="22%">
                <div align="left"><code>Math</code>.<code>exp(x)</code></div>
            </td>
        </tr>
        <tr>
            <td width="28%">
                <div align="left"><code><b>double</b> log(<b>double</b> a)</code></div>
            </td>
            <td width="50%">
                <div align="left">Вычисление натурального логарифма</div>
            </td>
            <td width="22%">
                <div align="left"><code>Math</code>.<code>log(x)</code></div>
            </td>
        </tr>
        <tr>
            <td width="28%" height="23">
                <div align="left"><b><code>double</code></b><code> abs(<b>double</b> a)</code></div>
                <code><b>int</b> abs(<b>int</b> a)</code></td>
            <td width="50%" height="23">
                <div align="left">Определение модуля числа</div>
            </td>
            <td width="22%" height="23">
                <div align="left"><code>Math</code>.<code>abs(x)</code></div>
            </td>
        </tr>
        <tr>
            <td width="28%" height="12">
                <div align="left"><code><b>long</b> round(<b>double</b> a)</code></div>
            </td>
            <td width="50%" height="12">
                <div align="left">Округление до ближайшего целого</div>
            </td>
            <td width="22%" height="12">
                <div align="left"><code>Math</code>.<code>round(x)</code></div>
            </td>
        </tr>
        </tbody>
    </table>
    <p>Кроме математических функций, класс <code>Math</code> предоставляет такие полезные константы, как
        <code>Math.PI</code>, <code>Math.E</code>.</p>
    <p>Если классы находятся в других пакетах (не в <code>java.lang</code>), для вызова этих функций следует применять
        префикс <code>-</code> <code>имя_пакета.имя_классса</code>. Если необходимы классы вложенных пакетов, префикс
        будет еще более сложным. Для того, чтобы обойтись без использования полных имен, применяется конструкция
        <b><code>import</code></b>.</p>
    <p>Не следует включать в программу утверждение <b><code>import</code></b><code> java.lang.*</code>. Этот пакет
        импортируется автоматически.</p>
    <p>В ранних версиях Java (до JDK 1.4 включительно) обращение к отдельным функциям классов требовало явного указания
        класса (или объекта для нестатических функций). Например:</p>
    <blockquote>
        <pre><b>double</b> d = Math.sin(1); // sin() - статическая функция класса<code> java.lang.Math</code></pre>
    </blockquote>
    <p>Дополнительная форма импорта, появившаяся в Java 5, позволяет импортировать только статические элементы
        указанного класса:</p>
    <blockquote>
        <pre><b>import static</b> java.lang.Math.*;</pre>
    </blockquote>
    <p>Теперь статические элементы можно использовать без дополнительного квалификатора, например:</p>
    <blockquote>
        <pre><b>double</b> d = sin(1);</pre>
    </blockquote>
    <h2>2 Примеры программ</h2>
    <h3>2.1  Сумма цифр</h3>
    <p>Допустим, необходимо определить сумму цифр числа. Можно использовать нахождение остатка от деления.</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> SumOfDigits {

    <b>public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        <b>int</b> n = scanner.nextInt();
        <b>int</b> sum = 0;
        <b>while</b> (n &gt; 0) {
            sum += n % 10;
            n /= 10;
        }
        System.out.println(sum);
    }

}</pre>
    </blockquote>
    <h3>2.2 Вычисление экспоненты</h3>
    <p>Предположим, что мы хотим написать программу, которая считывает <i>x</i> и вычисляет <i>e<sup>x</sup></i>:</p>
    <div align="center"><i>y</i> = <i>e<sup>x</sup></i> = 1 + <i>x</i> + <i>x</i><sup>2</sup><font
            size="+1">/<sub>2!</sub></font> + <i>x</i><sup>3</sup><font size="+1">/<sub>3!</sub></font> + ...</p>
    <p>Цикл прекращается, если новое слагаемое меньше 0.00001.</div>
    <p>Первый вариант использует цикл <b><code>while</code></b>:</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> Exponent {

    <b>public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        <b>double</b> x = scanner.nextDouble();
        <b>double</b> z = 1; // слагаемое
        <b>int</b> i = 1;
        <b>double</b> y = 0;
        <b>while</b> (z &gt; 0.00001) {
            y += z;
            z *= x / i;
            i++;
        }
        System.out.println(&quot;y = &quot; + y);
    }

}</pre>
    </blockquote>
    <p>Альтернативное решение (цикл <code><b>for</b></code>):</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> Exponent {

    <b>public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        <b>double</b> x = scanner.nextDouble();
        <b>double</b> z = 1; // слагаемое
        <b>double</b> y = 0;
        <b>for</b> (<b>int</b> i = 1; z &gt; 0.00001; i++) {
            y += z;
            z *= x / i;
        }
        System.out.println(&quot;y = &quot; + y);
    }

}</pre>
    </blockquote>
    <h3>2.3 Степени числа 2</h3>
    <p>Допустим, нам необходимо получить значения степеней 2 до заданного <code>n</code> (от 0 до 30) включительно.
        Можно реализовать два варианта &#8211 с использованием арифметических действий и побитовых операций.</p>
    <h4>2.3.1 Использование арифметических операций</h4>
    <p> В созданный ранее пакет добавляем новый класс с именем <code>Powers</code>. Для выполнения однотипных действий
        целесообразно создать цикл, в теле которого вычисляется очередная степень 2 и выводится на экран.</p>
    <p>На Java алгоритм вычисления можно представить в следующем виде:</p>
    <blockquote>
      <pre><b><b>int</b></b> n = ... // ввод n
<b>final int</b> k = 2;  // основание
<b>int</b> power = 1;
<b>for</b> (<b>int</b> i = 0; i &lt;= n; i++) {
    System.out.printf(&quot;2 ^ %2d = %d\n&quot;, i, power);
    power *= k;
}</pre>
    </blockquote>
    <p>В данном примере для описания переменных используется тип <b><code>int</code></b> (целый), так как и основание, и
        показатель, и степень &#8211 целые числа. Начальное значение результата</p>
    <blockquote>
        <pre><b>int</b> power = 1;</pre>
    </blockquote>
    <p>типично для вычисления произведений последовательностей. Как видно из примера, параметр цикла можно определять
        непосредственно в заголовке цикла. Для умножения, как и в других языках программирования, используется знак
        звездочки. Для домножения числа можно вместо традиционного для многих языков утверждения</p>
    <blockquote>
        <pre>power = power * k;    </pre>
    </blockquote>
    <p>писать</p>
    <blockquote>
        <pre>power *= k;    </pre>
    </blockquote>
    <p>Программа будет иметь вид:</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> Powers {

    <b>public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        System.out.println(&quot;Введите n в диапазоне от 0 до 30&quot;);
        <b>int</b> n = scanner.nextInt();
        <b>int</b> power = 1;
        <strong>final</strong> <b>int</b> k = 2;
        <b>if</b> (n &lt; 0 || n &gt; 30) {
            System.err.println(&quot;Неправильное значение n&quot;);
        }
    <b>    else</b> {
            <b>for</b> (<b>int</b> i = 0; i &lt;= n; i++) {
                System.out.printf(&quot;2 ^ %2d = %d\n&quot;, i, power);
                power *= k;
            }
        }
    }

}</pre>
    </blockquote>
    <h4>2.3.2 Использование побитовых операций</h4>
    <p>Наиболее эффективным будет подход, использующий побитовую операцию сдвига.</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> PowersOfTwo {

    <b>public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        System.out.println(&quot;Введите n в диапазоне от 0 до 30&quot;);
        <b>int</b> n = scanner.nextInt();
        <b>if</b> (n &lt; 0 || n &gt; 30) {
            System.err.println(&quot;Неправильное значение n!&quot;);
        }
        <b>else</b> {
            <b>for</b> (<b>int</b> i = 0; i &lt;= n; i++) {
                System.out.printf(&quot;2 ^ %2d = %d\n&quot;, i, 1 &lt;&lt; i);
            }
        }
    }

}</pre>
    </blockquote>
    <h3>2.4 Двоичное представление числа</h3>
    <p>Необходимо получить двоичное представление заданного числа.</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> ToBinary {

    <b>public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
    <b>    byte</b> b = scanner.nextByte();
    <b>    for</b> (<b>int</b> i = 7; i &gt;= 0; i--) {
            System.out.print((<b>byte</b>)(1 &amp; (b &gt;&gt; i)));
        }
    }

}</pre>
    </blockquote>
    <p>В приведенном выше цикле исходное число смещается на различное количество разрядов и младший бит результата
        выделяется путем выполнения операции И с единицей. Функция <code>System.out.print()</code> без параметров
        используется для вывода данных без перевода строки.</p>
    <h3>2.5 Наибольший общий делитель</h3>
    <p>Допустим, необходимо разработать функцию, которая вычисляет и возвращает наибольший общий делитель двух целых
        чисел. Воспользуемся алгоритмом Евклида, который заключается в следующем. Нужно из большего числа вычесть
        меньшее и заменить большее число результатом, а меньшее оставить без изменений. Это действие нужно повторять до
        тех пор, пока оба числа не станут равными <code>-</code> каждое из них и есть искомый наибольший общий делитель.
    </p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> GreatestCommonDivisor {

    <b>static int</b> gcd(<b>int</b> m, <b>int</b> n) {
        <b>while</b> (m != n) {
            <b>if</b> (m &gt; n) {
                m -= n;
            }
            <b>else</b> {
                n -= m;
            }
        }
    <b>    return</b> m;
    }

    <b>public static void</b> main(String[] args) {
        Scanner s = <b>new</b> Scanner(System.in);
        <b>int</b> m = s.nextInt();
        <b>int</b> n = s.nextInt();
        System.out.println(gcd(m, n));
    }

}</pre>
    </blockquote>
    <h3>2.6 Функция для вычисления целой степени</h3>
    <p>Следующая программа демонстрирует создание и использование статической функции, которая вычисляет целую степень
        вещественного числа. Программа будет иметь вид:</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> PowerTest {

    <b>static double</b> power(<b>double</b> x, <b>int</b> n) {
        <b>double</b> p = 1;
        <b>if</b> (n &gt;= 0) {
            <b>for</b> (<b>int</b> i = 1; i &lt;= n; i++) {
                p *= x;
            }
            <b>return</b> p;
        }
        <b>else</b> {
      <b>      for</b> (<b>int</b> i = 1; i &lt;= -n; i++) {
                p *= x;
            }
            <b>return</b> 1 / p;
        }
    }

  <b>  public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        <b>double</b> x = scanner.nextDouble();
        <b>int</b> n = scanner.nextInt();
        <b>double</b> y = power(x, n);
        System.out.println(y);
    }

}</pre>
    </blockquote>
    <h3>2.7 Вычисления целой степени с использованием рекурсии</h3>
    <p>Программу предыдущего примера можно реализовать с помощью рекурсивной функции:</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> RecursionTest {

    <b>static double</b> power(<b>double</b> x, <b>int</b> n) {
        <b>if</b> (n &lt; 0) {
            <b>return</b> 1 / power(x, -n);
        }
        <b>if</b> (n == 0) {
            <b>return</b> 1;
        }
        <b>return</b> x * power(x, n - 1);
    }

    <b>public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        <b>double</b> x = scanner.nextDouble();
        <b>int</b> n = scanner.nextInt();
        <b>double</b> y = power(x, n);
        System.out.println(y);
    }

}</pre>
    </blockquote>
    <h3>2.8 Вычисление <span style="font-family: Times New Roman,Times,serif; font-size: x-large;">π</span></h3>
    <p>Один из способов вычисления числа <span style="font-family: Times New Roman,Times,serif; font-size: x-large;">π</span>, является подсчет суммы следующего ряда:</p>
    <p><div align="center"><img src="Images/03_pi_1.png" alt="" width="345" height="42" /></div></p>
    <p>Необходимо реализовать и протестировать функцию, которая вычисляет <span style="font-family: Times New Roman,Times,serif; font-size: x-large;">π</span> с точностью до заданного <span style="font-family: Times New Roman,Times,serif; font-size: x-large;">ε</span> вычисление должно прекращаться, если очередное слагаемое меньше <span style="font-family: Times New Roman,Times,serif; font-size: x-large;">ε</span> по абсолютной величине. Необходимо реализовать два варианта вычислений - с рекурсией и без рекурсии.</p>
    <h4>2.8.1 Использование цикла</h4>
    <p>Вначале реализуем вариант без рекурсии. Программа с функцией будет иметь следующий вид:</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> PiTest {

    <b>static double</b> pi(<b>double</b> eps) {
        <b>double</b> sum = 0;
        <b>double</b> k = 1;
        <b>double</b> z = 4;
        <b>double</b> i = 1;
        <b>while</b> (Math.abs(z) &gt; eps) {
            sum += z;
            i += 2;
            k = -k;
            z = (4 * k) / i;
        }
        <b>return</b> sum;
    }

    <b>public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        <b>double</b> eps = scanner.nextDouble();
        <b>double</b> y = pi(eps);
        System.out.println(y);
    }

}</pre>
    </blockquote>
    <p>В данном варианте можно вводить сколь угодно маленькое значение точности. Однако при слишком маленьких значениях процесс может затянуться.</p>
    <h4>2.8.2 Использование рекурсии</h4>
    <p>Второй вариант использует рекурсию. Основная рекурсивная функция - с двумя параметрами. Вначале ее нужно вызвать со значением параметра 1. Для удобства использования предлагается вариант с одним параметром. Программа с функцией будет иметь следующий вид:</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> PiWithRecursion {

    <b>static double</b> pi(<b>double</b> eps, <b>int</b> n) {
        <b>double</b> z = 4.0 / n;
        <b>if</b> (z &lt; eps) {
            <b>return</b> z;
        }
        <b>return</b> z - pi(eps, n + 2);
    }

    <b>static double</b> pi(<b>double</b> eps) {
        <b>return</b> pi(eps, 1);
    }

    <b>public static void</b> main(String[] args) {
        Scanner scanner = <b>new</b> Scanner(System.in);
        <b>double</b> eps = scanner.nextDouble();
        <b>double</b> y = pi(eps);
        System.out.println(y);
    }

}</pre>
    </blockquote>
    <p>Недостатками реализации с рекурсией является большое время работы и переполнение программного стека. В нашем случае можно получить результат только для точности порядка одной миллиардной.</p>
    <h3>2.9 Разделение программы на независимые части</h3>
    <p>Почти каждая программа может быть разделена на относительно независимые части. Таким способом реализуется структурная (процедурная) парадигма программирования. Программа, которая вычисляет некоторые значения, как правило, содержит части, отвечающие за ввод, расчет и вывод. Предположим, что нам необходимо реализовать программу, которая вычисляет сумму вторых степеней целых чисел:</p>
    <p><div align="center"><i>y</i> = 1<sup>2</sup> + 2<sup>2</sup> + 3<sup>2</sup> + ... + <i>n</i><sup>2</sup></div></p>
    <p>Первая реализация (без разделения на части):</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> SplitDemo {

    <b>public static void</b> main(String[] args) {
        <b>int</b> n;
        System.out.println(&quot;Input n:&quot;);
        n = <b>new</b> Scanner(System.in).nextInt();
        <b>int</b> y = 0;
        <b>for</b> (<b>int</b> i = 1; i &lt;= n; i++) {
            y += i * i;
        }
        System.out.println(&quot;y = &quot; + y);
    }

}</pre>
    </blockquote>
    <p>Самое простое решение разделения на отдельные функции заключается в использовании статических полей, которые фактически заменяют собой отсутствующие в Java глобальные переменные:</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> SplitDemo {
    <b>static int</b> n;
    <b>static int</b> y = 0;

    <b>static void</b> read() {
        System.out.println(&quot;Input n:&quot;);
        n = <b>new</b> Scanner(System.in).nextInt();
    }

    <b>static void</b> calc() {
        <b>for</b> (<b>int</b> i = 1; i &lt;= n; i++) {
            y += i * i;
        }
    }

    <b>static void</b> write()
    {
        System.out.println(&quot;y = &quot; + y);
    }

    <b>public static void</b> main(String[] args) {
        read();
        calc();
        write();
    }

}</pre>
    </blockquote>
    <p>Использование статических полей затрудняет отслеживание жизненного цикла переменных. В частности, компилятор не в состоянии отследить, было ли присвоено полю какое-либо осмысленное значение. Лучший подход заключается в использовании аргументов:</p>
    <blockquote>
      <pre><b>package</b> ua.inf.iwanoff.third;

<b>import</b> java.util.Scanner;

<b>public class</b> SplitDemo {

    <b>static int</b> read() {
        System.out.println(&quot;Input n:&quot;);
        <b>return new</b> Scanner(System.in).nextInt();
    }

    <b>static int</b> calc(<b>int</b> n) {
        <b>int</b> y = 0;
        <b>for</b> (<b>int</b> i = 1; i &lt;= n; i++)
            y += i * i;
        <b>return</b> y;
    }

    <b>static void</b> write(<b>int</b> y) {
        System.out.println(&quot;y = &quot; + y);
    }

    <b>public static void</b> main(String[] args) {
        <b>int</b> n = read();
        <b>int</b> y = calc(n);
        write(y);
    }

}</pre>
    </blockquote>
    <p>Функция <code>main()</code> может быть реализована без каких-либо переменных.</p>
    <blockquote>
      <pre>  ...
  <b>public static void</b> main(String[] args) {
      write(calc(read()));
  }</pre>
    </blockquote>
    <h2>3 Задания на самостоятельную работу</h2>
    <p><span class="justified"><em>Примечание</em>: здесь и далее звездочкой отмечены задания, обязательные к выполнению.</span>
    </p>
    <h3>3.1 Решение квадратного уравнения</h3>
    <p align="left">Разработайте программу, которая реализует алгоритм решения квадратного уравнения. Алгоритм должен
        учитывать все возможные данные.</p>
    <h3>3.2 Сумма бесконечного ряда</h3>
    <p>Ввести значение <code>eps</code> и найти сумму ряда</p>
    <div align="center"><i>y</i> = 1 + <sup>1</sup>/<sub>2</sub> + <sup>1</sup>/<sub>4</sub> + <sup>1</sup>/<sub>8</sub>
        + <sup>1</sup>/<sub>16</sub> + ... </div>
    <p>Добавлять слагаемые до тех пор, пока очередное слагаемое не станет меньше <code>eps</code>.</p>
    <h3>3.3 Степени числа 8*</h3>
    <p>Ввести значение <code>n</code> (от 0 до 10) и вывести значения степеней числа 8 до <code>n</code> включительно.
        Реализовать два подхода &#8211 с использованием арифметических и побитовых операций.</p>
    <h3>3.4 Двоичное представление числа*</h3>
    <p>Изменить программу двоичного представления числа так, чтобы не выводились нули вначале. Использовать булеву
        переменную для индикации того, первый ли это ноль.</p>
    <h3>3.6 Двоичное обратное представление числа*</h3>
    <p>Написать программу инвертированного двоичного представления числа так (в обратном порядке, слева &#8211 младшие
        биты, а справа &#8211 старшие).</p>
    <h3>3.5 Наибольший общий делитель</h3>
    <p>Реализовать функцию, которая вычисляет наибольший общий делитель двух чисел через использование рекурсии.</p>
    <h3>3.6 Поиск простых чисел</h3>
    <p>Реализовать программу поиска простых чисел. Проверку, является ли число простым, осуществлять в отдельной
        функции, которая принимает целое число и возвращает результат типа <b><code>boolean</code></b>. В функции <code>main()</code>&nbsp;осуществить
        ввод необходимого диапазона и вывод всех простых чисел в этом диапазоне.</p>
    <h3>3.7 Определение чисел Фибоначчи*</h3>
    <p>Реализовать программу поиска чисел Фибоначчи:</p>
    <div align="center" class="style1"><i>F</i>(1) = <i>F</i>(2) = 1; <i>F</i>(<i>n</i>) = <i>F</i>(<i>n</i> - 2) +
        <i>F</i>(<i>n</i> - 1)
    </div>
    <p>Поиск n-го числа Фибоначчи осуществлять в отдельной функции. В функции <code>main()</code>&nbsp;осуществить ввод
        номера числа и вывод всех чисел Фибоначчи до введенного номера включительно. Реализовать два варианта - с
        использованием цикла и с использованием рекурсии.</p>
    <h3>3.8 Вычисление <span style="font-family: Times New Roman,Times,serif; font-size: x-large;">π</span>*</h3>
    <p>Реализовать и протестировать функцию, которая вычисляет <span
            style="font-family: Times New Roman,Times,serif; font-size: x-large;">π</span> с точностью до заданного
        <span style="font-family: Times New Roman,Times,serif; font-size: x-large;">ε</span> по следующей формуле.</p>
    <div align="center"><img src="Images/03_pi_2.png" alt="" width="528" height="42"/></div>
    <p>Параметром функции должна быть точность (<span
            style="font-family: Times New Roman,Times,serif; font-size: x-large;">ε</span>). Вычисление должно
        прекращаться, если очередное слагаемое меньше <span
                style="font-family: Times New Roman,Times,serif; font-size: x-large;">ε </span>по абсолютной величине.
        Реализовать два варианта - с использованием цикла и с использованием рекурсии.</p>
    <h2>4 Контрольные вопросы</h2>
    <ol>
        <li>Что такое лексема?</li>
        <li>Перечислите правила определения имен идентификаторов.</li>
        <li>Какая разница между ключевыми и зарезервированными словами?</li>
        <li>Можно ли в комментарий стиля C вложить другой комментарий стиля C?</li>
        <li>Чем отличаются комментарии Javadoc от других видов комментариев?</li>
        <li>Каким значением автоматически инициализируются вновь создаваемые локальные переменные?</li>
        <li>Можно ли использовать слово <b><code>const</code></b> для описания константы на Java?</li>
        <li>Размеры каких встроенных типов данных отличаются в различных реализациях Java?</li>
        <li>Как привести значение выражения типа <b><code>boolean</code></b> к целому типу?</li>
        <li>Как привести целое значение к значению типа <b><code>boolean</code></b>?</li>
        <li>На какие группы делятся операции по количеству операндов?</li>
        <li>Как получить дробное значение в результате деления двух целых чисел?</li>
        <li>Что происходит с младшими битами целого числа при побитовом сдвиге вправо?</li>
        <li>Для чего используется составное присваивание?</li>
        <li>Чем отличается префиксная и постфиксная форма инкремента и декремента?</li>
        <li>Можно ли применять операцию <code>&amp;</code> вместо <code>&amp;&amp;</code> для операндов типа <b><code>boolean</code></b>?
        </li>
        <li>Где может быть использована операция &quot;запятая&quot;?</li>
        <li>Для чего используется пустая инструкция?</li>
        <li>Как обратиться из внутреннего блока к локальной переменной наружного блока, если ее имя переопределено во
            внутреннем блоке?
        </li>
        <li>Можно ли использовать в переключателе выражение типа <b><code>double</code></b> для проверки условия
            ветвления?
        </li>
        <li>Какие существуют типы циклических конструкций и чем они отличаются по своему использованию?</li>
        <li>Тело какого из циклов всегда выполняется не зависимо от условия повторения?</li>
        <li>Всегда ли требуется метка при использовании <b><code>break</code></b>?</li>
        <li>Какие существуют средства поддержки ввода данных во время работы программы?</li>
        <li>Для чего используется класс Scanner?</li>
        <li>Как с помощью объекта класса Scanner прочитать целое значение?</li>
        <li>Как осуществляется форматированный вывод?</li>
        <li>Чем определяются типы параметров функции printf()?</li>
        <li>Что такое аргумент командной строки?</li>
        <li>Как в Java-программе использовать аргументы командной строки?</li>
        <li>Для чего используются статические поля?</li>
        <li>Что такое стек вызовов (программный стек)?</li>
        <li>Чем статические поля отличаются от глобальных и локальных переменных?</li>
        <li>С какой целью фрагменты кода выделяют в отдельные функции?</li>
        <li>В чем различие между формальными и фактическими параметрами?</li>
        <li>Как осуществляется сопоставление параметров при вызове функции?</li>
        <li>На что влияет тип возвращаемого значения функции?</li>
        <li>Для чего используются функции с результатом типа <b><code>void</code></b>?</li>
        <li>Обязательно ли использование утверждения <b><code>return</code></b> в теле функции?</li>
        <li>Можно ли использовать <b><code>return</code></b> в теле функции, возвращающей <b><code>void</code></b>?</li>
        <li>Можно ли передать параметры типов-значений по ссылке?</li>
        <li>В чем преимущества перегрузки имен функций?</li>
        <li>Можно ли в Java использовать параметры функций по умолчанию? С какой целью?</li>
        <li>Что такое рекурсия?</li>
        <li>В чем различие между прямой и косвенной рекурсией?</li>
        <li>Какие проблемы связаны с некорректным использованием рекурсии?</li>
        <li>В чем преимущества использования статического импорта?</li>
        <li>Можно ли обращаться к функциям из другого пакета, не используя инструкции <b><code>import</code></b>?</li>
    </ol>
    <p>&nbsp;</p>
    <div class="w3-clear nextprev">
        <a class="btn btn-info float-left" href="topic_1_02.html">Предыдущая</a>
        <a class="btn btn-info float-left" href="topic_1_04.html">Следующая</a>
    </div>
</div>
</div>

</div>
</div>
<a href="#top" id="up">up</a>
<footer class="container-fluid text-center">
    <p>&copy; 2003-2019 Л.В.Иванов</p>
</footer>
<script>
    $(document).ready(function () {
        // Add smooth scrolling to all links in navbar + footer link
        $("a[href='#top']").on('click', function (event) {

            // Make sure this.hash has a value before overriding default behavior
            if (this.hash !== "") {

                // Prevent default anchor click behavior
                event.preventDefault();

                // Store hash
                var hash = this.hash;

                // Using jQuery's animate() method to add smooth page scroll
                // The optional number (900) specifies the number of milliseconds it takes to scroll to the specified area
                $('html, body').animate({
                    scrollTop: $(hash).offset().top
                }, 900, function () {

                    // Add hash (#) to URL when done scrolling (default click behavior)
                    window.location.hash = hash;
                });
            } // End if
        });
        var offset = 200;
        var duration = 300;
        $('#up').fadeOut(0);
        $(window).scroll(function () {
            var winTop = $(window).scrollTop();
            if (winTop > offset) {
                $('#up').css("opacity", "0.8");
                $('#up').fadeIn(duration);
            } else {
                $('#up').fadeOut(duration);
            }
        });
    })
</script>

</body>
</html>
